// node_modules/@syncfusion/ej2-file-utils/src/save.js
var Save = (
  /** @class */
  function() {
    function Save2() {
    }
    Save2.save = function(fileName, buffer) {
      if (fileName === null || fileName === void 0 || fileName === "") {
        throw new Error("ArgumentException: fileName cannot be undefined, null or empty");
      }
      var extension = fileName.substring(fileName.lastIndexOf(".") + 1, fileName.length);
      var mimeType = this.getMimeType(extension);
      if (mimeType !== "") {
        buffer = new Blob([buffer], { type: mimeType });
      }
      if (this.isMicrosoftBrowser) {
        navigator.msSaveBlob(buffer, fileName);
      } else {
        var downloadLink = document.createElementNS("http://www.w3.org/1999/xhtml", "a");
        this.saveInternal(fileName, extension, buffer, downloadLink, "download" in downloadLink);
      }
    };
    Save2.saveInternal = function(fileName, extension, buffer, downloadLink, hasDownloadAttribute) {
      if (hasDownloadAttribute) {
        downloadLink.download = fileName;
        var dataUrl_1 = window.URL.createObjectURL(buffer);
        downloadLink.href = dataUrl_1;
        var event_1 = document.createEvent("MouseEvent");
        event_1.initEvent("click", true, true);
        downloadLink.dispatchEvent(event_1);
        setTimeout(function() {
          window.URL.revokeObjectURL(dataUrl_1);
          dataUrl_1 = void 0;
        });
      } else {
        if (extension !== "docx" && extension !== "xlsx") {
          var url = window.URL.createObjectURL(buffer);
          var isPopupBlocked = window.open(url, "_blank");
          if (!isPopupBlocked) {
            window.location.href = url;
          }
        } else {
          var reader_1 = new FileReader();
          reader_1.onloadend = function() {
            var isPopupBlocked2 = window.open(reader_1.result, "_blank");
            if (!isPopupBlocked2) {
              window.location.href = reader_1.result;
            }
          };
          reader_1.readAsDataURL(buffer);
        }
      }
    };
    Save2.getMimeType = function(extension) {
      var mimeType = "";
      switch (extension) {
        case "html":
          mimeType = "text/html";
          break;
        case "pdf":
          mimeType = "application/pdf";
          break;
        case "docx":
          mimeType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
          break;
        case "xlsx":
          mimeType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
          break;
        case "txt":
          mimeType = "text/plain";
          break;
      }
      return mimeType;
    };
    return Save2;
  }()
);

// node_modules/@syncfusion/ej2-file-utils/src/xml-writer.js
var XmlWriter = (
  /** @class */
  function() {
    function XmlWriter2() {
      this.contentPos = 0;
      this.bufferText = "";
      this.bufferBlob = new Blob([""], { type: "text/plain" });
      this.currentState = "Initial";
      this.namespaceStack = [];
      this.namespaceStack.push(new Namespace());
      this.namespaceStack[0].set("xmlns", "http://www.w3.org/2000/xmlns/", "Special");
      this.namespaceStack.push(new Namespace());
      this.namespaceStack[1].set("xml", "http://www.w3.org/XML/1998/namespace", "Special");
      this.namespaceStack.push(new Namespace());
      this.namespaceStack[2].set("", "", "Implied");
      this.elementStack = [];
      this.elementStack.push(new XmlElement());
      this.elementStack[0].set("", "", "", this.namespaceStack.length - 1);
      this.attributeStack = [];
      Save.isMicrosoftBrowser = !!navigator.msSaveBlob;
    }
    Object.defineProperty(XmlWriter2.prototype, "buffer", {
      /**
       * Gets the content written to the {XmlWriter} as Blob.
       * @returns {Blob}
       */
      get: function() {
        this.flush();
        return this.bufferBlob;
      },
      enumerable: true,
      configurable: true
    });
    XmlWriter2.prototype.writeProcessingInstruction = function(name, text) {
      if (name === void 0 || name === null || name.length === 0) {
        throw new Error("ArgumentException: name should not be undefined, null or empty");
      }
      this.checkName(name);
      if (text === void 0 || text === null) {
        text = "";
      }
      if (name.length === 3 && name === "xml") {
        if (this.currentState !== "Initial") {
          throw new Error("InvalidArgumentException: Cannot write XML declaration.WriteStartDocument method has already written it");
        }
      }
      if (this.currentState !== "Initial" || this.bufferBlob === void 0) {
        throw new Error("InvalidOperationException: Wrong Token");
      } else {
        this.writeStartDocument();
        this.writeProcessingInstructionInternal(name, text);
      }
    };
    XmlWriter2.prototype.writeStartDocument = function(standalone) {
      if (this.currentState !== "Initial" || this.bufferBlob === void 0) {
        throw new Error("InvalidOperationException: Wrong Token");
      }
      this.currentState = "StartDocument";
      this.rawText('<?xml version="1.0" encoding="utf-8');
      if (standalone !== null && standalone !== void 0) {
        this.rawText('" standalone="');
        this.rawText(standalone ? "yes" : "no");
      }
      this.rawText('"?>');
    };
    XmlWriter2.prototype.writeEndDocument = function() {
      while (this.elementStack.length - 1 > 0) {
        this.writeEndElement();
      }
      this.currentState = "EndDocument";
      this.flush();
    };
    XmlWriter2.prototype.writeStartElement = function(prefix, localName, namespace) {
      if (this.bufferBlob === void 0) {
        throw new Error("InvalidOperationException: Wrong Token");
      }
      if (localName === void 0 || localName === null || localName.length === 0) {
        throw new Error("ArgumentException: localName cannot be undefined, null or empty");
      }
      this.checkName(localName);
      if (this.currentState === "Initial") {
        this.writeStartDocument();
      }
      if (this.currentState === "StartElement") {
        this.startElementContent();
      }
      this.currentState = "StartElement";
      if (prefix === void 0 || prefix === null) {
        if (namespace !== void 0 && namespace !== null) {
          prefix = this.lookupPrefix(namespace);
        }
        if (prefix === void 0 || prefix === null) {
          prefix = "";
        }
      } else if (prefix.length > 0) {
        if (namespace === void 0 || namespace === null) {
          namespace = this.lookupNamespace(prefix);
        }
        if (namespace === void 0 || namespace === null || namespace !== void 0 && namespace.length === 0) {
          throw new Error("ArgumentException: Cannot use a prefix with an empty namespace");
        }
      }
      if (namespace === void 0 || namespace === null) {
        namespace = this.lookupNamespace(prefix);
      }
      this.writeStartElementInternal(prefix, localName, namespace);
    };
    XmlWriter2.prototype.writeEndElement = function() {
      if (this.currentState === "StartElement") {
        this.startElementContent();
        this.currentState = "ElementContent";
      } else if (this.currentState === "ElementContent") {
        this.currentState = "ElementContent";
      }
      this.currentState = "EndElement";
      var top = this.elementStack.length - 1;
      this.writeEndElementInternal(this.elementStack[top].prefix, this.elementStack[top].localName);
      this.namespaceStack.splice(this.elementStack[top].previousTop + 1);
      this.elementStack.splice(top);
      if (this.bufferText.length > 10240) {
        this.flush();
      }
    };
    XmlWriter2.prototype.writeElementString = function(prefix, localName, namespace, value) {
      this.writeStartElement(prefix, localName, namespace);
      if (value !== void 0 && value !== null && value.length !== 0) {
        this.writeString(value);
      }
      this.writeEndElement();
    };
    XmlWriter2.prototype.writeAttributeString = function(prefix, localName, namespace, value) {
      this.writeStartAttribute(prefix, localName, namespace, value);
      this.writeStringInternal(value, true);
      this.writeEndAttribute();
    };
    XmlWriter2.prototype.writeString = function(text) {
      this.writeInternal(text, false);
    };
    XmlWriter2.prototype.writeRaw = function(text) {
      this.writeInternal(text, true);
    };
    XmlWriter2.prototype.writeInternal = function(text, isRawString) {
      if (text === void 0 || text === null) {
        return;
      } else {
        if (this.currentState !== "StartElement" && this.currentState !== "ElementContent") {
          throw new Error("InvalidOperationException: Wrong Token");
        }
        if (this.currentState === "StartElement") {
          this.startElementContent();
        }
        this.currentState = "ElementContent";
        if (isRawString) {
          this.rawText(text);
        } else {
          this.writeStringInternal(text, false);
        }
      }
    };
    XmlWriter2.prototype.save = function(fileName) {
      while (this.elementStack.length - 1 > 0) {
        this.writeEndElement();
      }
      if (this.bufferText !== "") {
        this.flush();
      }
      Save.save(fileName, this.buffer);
    };
    XmlWriter2.prototype.destroy = function() {
      this.bufferBlob = void 0;
      for (var i = 0; i < this.namespaceStack.length; i++) {
        this.namespaceStack[i].destroy();
      }
      this.namespaceStack = [];
      for (var i = 0; i < this.elementStack.length; i++) {
        this.elementStack[i].destroy();
      }
      this.elementStack = [];
      this.bufferText = "";
      this.contentPos = 0;
    };
    XmlWriter2.prototype.flush = function() {
      if (this.bufferBlob === void 0) {
        return;
      }
      this.bufferBlob = new Blob([this.bufferBlob, this.bufferText], { type: "text/plain" });
      this.bufferText = "";
    };
    XmlWriter2.prototype.writeProcessingInstructionInternal = function(name, text) {
      this.bufferText += "<?";
      this.rawText(name);
      if (text.length > 0) {
        this.bufferText += " ";
        text = text.replace(/\?\>/g, "? >");
        this.bufferText += text;
      }
      this.bufferText += "?";
      this.bufferText += ">";
    };
    XmlWriter2.prototype.writeStartAttribute = function(prefix, localName, namespace, value) {
      if (localName === void 0 || localName === null || localName.length === 0) {
        if (prefix === "xmlns") {
          localName = "xmlns";
          prefix = "";
        } else {
          throw new Error("ArgumentException: localName cannot be undefined, null or empty");
        }
      }
      if (this.currentState !== "StartElement") {
        throw new Error("InvalidOperationException: Wrong Token");
      }
      this.checkName(localName);
      this.writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value);
    };
    XmlWriter2.prototype.writeStartAttributePrefixAndNameSpace = function(prefix, localName, namespace, value) {
      if (prefix === void 0 || prefix === null) {
        if (namespace !== void 0 && namespace !== null) {
          if (!(localName === "xmlns" && namespace === "http://www.w3.org/2000/xmlns/")) {
            prefix = this.lookupPrefix(namespace);
          }
        }
        if (prefix === void 0 || prefix === null) {
          prefix = "";
        }
      }
      if (namespace === void 0 || namespace === null) {
        if (prefix !== void 0 && prefix !== null && prefix.length > 0) {
          namespace = this.lookupNamespace(prefix);
        }
        if (namespace === void 0 || namespace === null) {
          namespace = "";
        }
      }
      this.writeStartAttributeSpecialAttribute(prefix, localName, namespace, value);
    };
    XmlWriter2.prototype.writeStartAttributeSpecialAttribute = function(prefix, localName, namespace, value) {
      if (prefix.length === 0) {
        if (localName[0] === "x" && localName === "xmlns") {
          this.skipPushAndWrite(prefix, localName, namespace);
          this.pushNamespaceExplicit("", value);
          return;
        } else if (namespace.length > 0) {
          prefix = this.lookupPrefix(namespace);
        }
      } else {
        if (prefix[0] === "x") {
          if (prefix === "xmlns") {
            this.skipPushAndWrite(prefix, localName, namespace);
            this.pushNamespaceExplicit(localName, value);
            return;
          } else if (prefix === "xml") {
            if (localName === "space" || localName === "lang") {
              this.skipPushAndWrite(prefix, localName, namespace);
              return;
            }
          }
        }
        if (namespace.length === 0) {
          prefix = "";
        }
      }
      if (prefix !== void 0 && prefix !== null && prefix.length !== 0) {
        this.pushNamespaceImplicit(prefix, namespace);
      }
      this.skipPushAndWrite(prefix, localName, namespace);
    };
    XmlWriter2.prototype.writeEndAttribute = function() {
      this.currentState = "StartElement";
      this.bufferText += '"';
    };
    XmlWriter2.prototype.writeStartElementInternal = function(prefix, localName, namespace) {
      this.bufferText += "<";
      if (prefix.length > 0) {
        this.rawText(prefix);
        this.bufferText += ":";
      }
      this.rawText(localName);
      var top = this.elementStack.length;
      this.elementStack.push(new XmlElement());
      this.elementStack[top].set(prefix, localName, namespace, this.namespaceStack.length - 1);
      this.pushNamespaceImplicit(prefix, namespace);
      for (var i = 0; i < this.attributeStack.length; i++) {
        this.attributeStack[i].destroy();
      }
      this.attributeStack = [];
    };
    XmlWriter2.prototype.writeEndElementInternal = function(prefix, localName) {
      if (this.contentPos !== this.bufferText.length + 1) {
        this.bufferText += "</";
        if (prefix !== void 0 && prefix !== null && prefix.length !== 0) {
          this.rawText(prefix);
          this.bufferText += ":";
        }
        this.rawText(localName);
        this.bufferText += ">";
      } else {
        this.bufferText = this.bufferText.substring(0, this.bufferText.length - 1);
        this.bufferText += " />";
      }
    };
    XmlWriter2.prototype.writeStartAttributeInternal = function(prefix, localName, namespaceName) {
      this.bufferText += " ";
      if (prefix !== void 0 && prefix !== null && prefix.length > 0) {
        this.rawText(prefix);
        this.bufferText += ":";
      }
      this.rawText(localName);
      this.bufferText += "=";
      this.bufferText += '"';
    };
    XmlWriter2.prototype.writeNamespaceDeclaration = function(prefix, namespaceUri) {
      this.writeStartNamespaceDeclaration(prefix);
      this.writeStringInternal(namespaceUri, true);
      this.bufferText += '"';
    };
    XmlWriter2.prototype.writeStartNamespaceDeclaration = function(prefix) {
      if (prefix === void 0 || prefix === null || prefix.length === 0) {
        this.rawText(' xmlns="');
      } else {
        this.rawText(" xmlns:");
        this.rawText(prefix);
        this.bufferText += "=";
        this.bufferText += '"';
      }
    };
    XmlWriter2.prototype.writeStringInternal = function(text, inAttributeValue) {
      if (text === null || text === void 0) {
        text = "";
      }
      var tempText = "";
      text = text.replace(/\&/g, "&amp;");
      text = text.replace(/\</g, "&lt;");
      text = text.replace(/\>/g, "&gt;");
      if (inAttributeValue) {
        text = text.replace(/\"/g, "&quot;");
      }
      this.bufferText += text;
      if (!inAttributeValue) {
        this.contentPos = 0;
      }
    };
    XmlWriter2.prototype.startElementContent = function() {
      var start = this.elementStack[this.elementStack.length - 1].previousTop;
      for (var i = this.namespaceStack.length - 1; i > start; i--) {
        if (this.namespaceStack[i].kind === "NeedToWrite") {
          this.writeNamespaceDeclaration(this.namespaceStack[i].prefix, this.namespaceStack[i].namespaceUri);
        }
      }
      this.bufferText += ">";
      this.contentPos = this.bufferText.length + 1;
    };
    XmlWriter2.prototype.rawText = function(text) {
      this.bufferText += text;
    };
    XmlWriter2.prototype.addNamespace = function(prefix, ns, kind) {
      var top = this.namespaceStack.length;
      this.namespaceStack.push(new Namespace());
      this.namespaceStack[top].set(prefix, ns, kind);
    };
    XmlWriter2.prototype.lookupPrefix = function(namespace) {
      for (var i = this.namespaceStack.length - 1; i >= 0; i--) {
        if (this.namespaceStack[i].namespaceUri === namespace) {
          return this.namespaceStack[i].prefix;
        }
      }
      return void 0;
    };
    XmlWriter2.prototype.lookupNamespace = function(prefix) {
      for (var i = this.namespaceStack.length - 1; i >= 0; i--) {
        if (this.namespaceStack[i].prefix === prefix) {
          return this.namespaceStack[i].namespaceUri;
        }
      }
      return void 0;
    };
    XmlWriter2.prototype.lookupNamespaceIndex = function(prefix) {
      for (var i = this.namespaceStack.length - 1; i >= 0; i--) {
        if (this.namespaceStack[i].prefix === prefix) {
          return i;
        }
      }
      return -1;
    };
    XmlWriter2.prototype.pushNamespaceImplicit = function(prefix, ns) {
      var kind;
      var existingNsIndex = this.lookupNamespaceIndex(prefix);
      if (existingNsIndex !== -1) {
        if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {
          if (this.namespaceStack[existingNsIndex].namespaceUri !== ns) {
            throw new Error("XmlException namespace Uri needs to be the same as the one that is already declared");
          }
          return;
        } else {
          if (this.namespaceStack[existingNsIndex].kind === "Special") {
            if (prefix === "xml") {
              if (ns !== this.namespaceStack[existingNsIndex].namespaceUri) {
                throw new Error("InvalidArgumentException: Xml String");
              } else {
                kind = "Implied";
              }
            } else {
              throw new Error('InvalidArgumentException: Prefix "xmlns" is reserved for use by XML.');
            }
          } else {
            kind = this.namespaceStack[existingNsIndex].namespaceUri === ns ? "Implied" : "NeedToWrite";
          }
        }
      } else {
        if (ns === "http://www.w3.org/XML/1998/namespace" && prefix !== "xml" || ns === "http://www.w3.org/2000/xmlns/" && prefix !== "xmlns") {
          throw new Error("InvalidArgumentException");
        }
        kind = "NeedToWrite";
      }
      this.addNamespace(prefix, ns, kind);
    };
    XmlWriter2.prototype.pushNamespaceExplicit = function(prefix, ns) {
      var existingNsIndex = this.lookupNamespaceIndex(prefix);
      if (existingNsIndex !== -1) {
        if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {
          this.namespaceStack[existingNsIndex].kind = "Written";
          return;
        }
      }
      this.addNamespace(prefix, ns, "Written");
      return;
    };
    XmlWriter2.prototype.addAttribute = function(prefix, localName, namespaceName) {
      var top = this.attributeStack.length;
      this.attributeStack.push(new XmlAttribute());
      this.attributeStack[top].set(prefix, localName, namespaceName);
      for (var i = 0; i < top; i++) {
        if (this.attributeStack[i].isDuplicate(prefix, localName, namespaceName)) {
          throw new Error("XmlException: duplicate attribute name");
        }
      }
    };
    XmlWriter2.prototype.skipPushAndWrite = function(prefix, localName, namespace) {
      this.addAttribute(prefix, localName, namespace);
      this.writeStartAttributeInternal(prefix, localName, namespace);
    };
    XmlWriter2.prototype.checkName = function(text) {
      var format = /[ !@#$%^&*()+\=\[\]{};':"\\|,<>\/?]/;
      if (format.test(text)) {
        throw new Error("InvalidArgumentException: invalid name character");
      }
    };
    return XmlWriter2;
  }()
);
var Namespace = (
  /** @class */
  function() {
    function Namespace2() {
    }
    Namespace2.prototype.set = function(prefix, namespaceUri, kind) {
      this.prefix = prefix;
      this.namespaceUri = namespaceUri;
      this.kind = kind;
    };
    Namespace2.prototype.destroy = function() {
      this.prefix = void 0;
      this.namespaceUri = void 0;
      this.kind = void 0;
    };
    return Namespace2;
  }()
);
var XmlElement = (
  /** @class */
  function() {
    function XmlElement2() {
    }
    XmlElement2.prototype.set = function(prefix, localName, namespaceUri, previousTop) {
      this.previousTop = previousTop;
      this.prefix = prefix;
      this.namespaceUri = namespaceUri;
      this.localName = localName;
    };
    XmlElement2.prototype.destroy = function() {
      this.previousTop = void 0;
      this.prefix = void 0;
      this.localName = void 0;
      this.namespaceUri = void 0;
    };
    return XmlElement2;
  }()
);
var XmlAttribute = (
  /** @class */
  function() {
    function XmlAttribute2() {
    }
    XmlAttribute2.prototype.set = function(prefix, localName, namespaceUri) {
      this.prefix = prefix;
      this.namespaceUri = namespaceUri;
      this.localName = localName;
    };
    XmlAttribute2.prototype.isDuplicate = function(prefix, localName, namespaceUri) {
      return this.localName === localName && (this.prefix === prefix || this.namespaceUri === namespaceUri);
    };
    XmlAttribute2.prototype.destroy = function() {
      this.prefix = void 0;
      this.namespaceUri = void 0;
      this.localName = void 0;
    };
    return XmlAttribute2;
  }()
);

// node_modules/@syncfusion/ej2-file-utils/src/encoding.js
var Encoding = (
  /** @class */
  function() {
    function Encoding2(includeBom) {
      this.emitBOM = true;
      this.encodingType = "Ansi";
      this.initBOM(includeBom);
    }
    Object.defineProperty(Encoding2.prototype, "includeBom", {
      /**
       * Gets a value indicating whether to write a Unicode byte order mark
       * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false
       */
      get: function() {
        return this.emitBOM;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Encoding2.prototype, "type", {
      /**
       * Gets the encoding type.
       * @returns EncodingType
       */
      get: function() {
        return this.encodingType;
      },
      /**
       * Sets the encoding type.
       * @param  {EncodingType} value
       */
      set: function(value) {
        this.encodingType = value;
      },
      enumerable: true,
      configurable: true
    });
    Encoding2.prototype.initBOM = function(includeBom) {
      if (includeBom === void 0 || includeBom === null) {
        this.emitBOM = true;
      } else {
        this.emitBOM = includeBom;
      }
    };
    Encoding2.prototype.getByteCount = function(chars) {
      var byteCount = 0;
      validateNullOrUndefined(chars, "string");
      if (chars === "") {
        var byte = this.utf8Len(chars.charCodeAt(0));
        return byte;
      }
      if (this.type === null || this.type === void 0) {
        this.type = "Ansi";
      }
      return this.getByteCountInternal(chars, 0, chars.length);
    };
    Encoding2.prototype.utf8Len = function(codePoint) {
      var bytes = codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : codePoint <= 2097151 ? 4 : 0;
      return bytes;
    };
    Encoding2.prototype.isHighSurrogate = function(codeUnit) {
      return codeUnit >= 55296 && codeUnit <= 56319;
    };
    Encoding2.prototype.toCodepoint = function(highCodeUnit, lowCodeUnit) {
      highCodeUnit = (1023 & highCodeUnit) << 10;
      var u = highCodeUnit | 1023 & lowCodeUnit;
      return u + 65536;
    };
    Encoding2.prototype.getByteCountInternal = function(chars, charIndex, charCount) {
      var byteCount = 0;
      if (this.encodingType === "Utf8" || this.encodingType === "Unicode") {
        var isUtf8 = this.encodingType === "Utf8";
        for (var i = 0; i < charCount; i++) {
          var charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);
          if (this.isHighSurrogate(charCode)) {
            if (isUtf8) {
              var high = charCode;
              var low = chars.charCodeAt(++charIndex);
              byteCount += this.utf8Len(this.toCodepoint(high, low));
            } else {
              byteCount += 4;
              ++i;
            }
          } else {
            if (isUtf8) {
              byteCount += this.utf8Len(charCode);
            } else {
              byteCount += 2;
            }
          }
          if (isUtf8) {
            charIndex++;
          }
        }
        return byteCount;
      } else {
        byteCount = charCount;
        return byteCount;
      }
    };
    Encoding2.prototype.getBytes = function(s, charIndex, charCount) {
      validateNullOrUndefined(s, "string");
      validateNullOrUndefined(charIndex, "charIndex");
      validateNullOrUndefined(charCount, "charCount");
      if (charIndex < 0 || charCount < 0) {
        throw new RangeError("Argument Out Of Range Exception: charIndex or charCount is less than zero");
      }
      if (s.length - charIndex < charCount) {
        throw new RangeError("Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string");
      }
      var bytes;
      if (s === "") {
        bytes = new ArrayBuffer(0);
        return bytes;
      }
      if (this.type === null || this.type === void 0) {
        this.type = "Ansi";
      }
      var byteCount = this.getByteCountInternal(s, charIndex, charCount);
      switch (this.type) {
        case "Utf8":
          bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);
          return bytes;
        case "Unicode":
          bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);
          return bytes;
        default:
          bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);
          return bytes;
      }
    };
    Encoding2.prototype.getString = function(bytes, index, count) {
      validateNullOrUndefined(bytes, "bytes");
      validateNullOrUndefined(index, "index");
      validateNullOrUndefined(count, "count");
      if (index < 0 || count < 0) {
        throw new RangeError("Argument Out Of Range Exception: index or count is less than zero");
      }
      if (bytes.byteLength - index < count) {
        throw new RangeError("Argument Out Of Range Exception: index and count do not denote a valid range in bytes");
      }
      if (bytes.byteLength === 0 || count === 0) {
        return "";
      }
      if (this.type === null || this.type === void 0) {
        this.type = "Ansi";
      }
      var out = "";
      var byteCal = new Uint8Array(bytes);
      switch (this.type) {
        case "Utf8":
          var s = this.getStringOfUtf8Encoding(byteCal, index, count);
          return s;
        case "Unicode":
          var byteUnicode = new Uint16Array(bytes);
          out = this.getStringofUnicodeEncoding(byteUnicode, index, count);
          return out;
        default:
          var j = index;
          for (var i = 0; i < count; i++) {
            var c = byteCal[j];
            out += String.fromCharCode(c);
            j++;
          }
          return out;
      }
    };
    Encoding2.prototype.getBytesOfAnsiEncoding = function(byteCount, s, charIndex, charCount) {
      var bytes = new ArrayBuffer(byteCount);
      var bufview = new Uint8Array(bytes);
      var k = 0;
      for (var i = 0; i < charCount; i++) {
        var charcode = s.charCodeAt(charIndex++);
        if (charcode < 2048) {
          bufview[k] = charcode;
        } else {
          bufview[k] = 63;
        }
        k++;
      }
      return bytes;
    };
    Encoding2.prototype.getBytesOfUtf8Encoding = function(byteCount, s, charIndex, charCount) {
      var bytes = new ArrayBuffer(byteCount);
      var uint = new Uint8Array(bytes);
      var index = charIndex;
      var j = 0;
      for (var i = 0; i < charCount; i++) {
        var charcode = s.charCodeAt(index);
        if (charcode <= 127) {
          uint[j] = charcode;
        } else if (charcode < 2048) {
          uint[j] = 192 | charcode >> 6;
          uint[++j] = 128 | charcode & 63;
        } else if (charcode < 55296 || charcode >= 57344) {
          uint[j] = 224 | charcode >> 12;
          uint[++j] = 128 | charcode >> 6 & 63;
          uint[++j] = 128 | charcode & 63;
        } else {
          uint[j] = 239;
          uint[++j] = 191;
          uint[++j] = 189;
        }
        ++j;
        ++index;
      }
      return bytes;
    };
    Encoding2.prototype.getBytesOfUnicodeEncoding = function(byteCount, s, charIndex, charCount) {
      var bytes = new ArrayBuffer(byteCount);
      var uint16 = new Uint16Array(bytes);
      for (var i = 0; i < charCount; i++) {
        var charcode = s.charCodeAt(i);
        uint16[i] = charcode;
      }
      return bytes;
    };
    Encoding2.prototype.getStringOfUtf8Encoding = function(byteCal, index, count) {
      var j = 0;
      var i = index;
      var s = "";
      for (j; j < count; j++) {
        var c = byteCal[i++];
        while (i > byteCal.length) {
          return s;
        }
        if (c > 127) {
          if (c > 191 && c < 224 && i < count) {
            c = (c & 31) << 6 | byteCal[i] & 63;
          } else if (c > 223 && c < 240 && i < byteCal.byteLength) {
            c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;
          } else if (c > 239 && c < 248 && i < byteCal.byteLength) {
            c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;
          }
          ++i;
        }
        s += String.fromCharCode(c);
      }
      return s;
    };
    Encoding2.prototype.getStringofUnicodeEncoding = function(byteUni, index, count) {
      if (count > byteUni.length) {
        throw new RangeError("ArgumentOutOfRange_Count");
      }
      var byte16 = new Uint16Array(count);
      var out = "";
      for (var i = 0; i < count && i < byteUni.length; i++) {
        byte16[i] = byteUni[index++];
      }
      out = String.fromCharCode.apply(null, byte16);
      return out;
    };
    Encoding2.prototype.destroy = function() {
      this.emitBOM = void 0;
      this.encodingType = void 0;
    };
    return Encoding2;
  }()
);
function validateNullOrUndefined(value, message) {
  if (value === null || value === void 0) {
    throw new Error("ArgumentException: " + message + " cannot be null or undefined");
  }
}

// node_modules/@syncfusion/ej2-file-utils/src/stream-writer.js
var StreamWriter = (
  /** @class */
  function() {
    function StreamWriter2(encoding) {
      this.bufferBlob = new Blob([""]);
      this.bufferText = "";
      this.init(encoding);
      Save.isMicrosoftBrowser = !!navigator.msSaveBlob;
    }
    Object.defineProperty(StreamWriter2.prototype, "buffer", {
      /**
       * Gets the content written to the StreamWriter as Blob.
       * @returns Blob
       */
      get: function() {
        this.flush();
        return this.bufferBlob;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(StreamWriter2.prototype, "encoding", {
      /**
       * Gets the encoding.
       * @returns Encoding
       */
      get: function() {
        return this.enc;
      },
      enumerable: true,
      configurable: true
    });
    StreamWriter2.prototype.init = function(encoding) {
      if (encoding === null || encoding === void 0) {
        this.enc = new Encoding(false);
        this.enc.type = "Utf8";
      } else {
        this.enc = encoding;
        this.setBomByte();
      }
    };
    StreamWriter2.prototype.setBomByte = function() {
      if (this.encoding.includeBom) {
        switch (this.encoding.type) {
          case "Unicode":
            var arrayUnicode = new ArrayBuffer(2);
            var uint8 = new Uint8Array(arrayUnicode);
            uint8[0] = 255;
            uint8[1] = 254;
            this.bufferBlob = new Blob([arrayUnicode]);
            break;
          case "Utf8":
            var arrayUtf8 = new ArrayBuffer(3);
            var utf8 = new Uint8Array(arrayUtf8);
            utf8[0] = 239;
            utf8[1] = 187;
            utf8[2] = 191;
            this.bufferBlob = new Blob([arrayUtf8]);
            break;
          default:
            this.bufferBlob = new Blob([""]);
            break;
        }
      }
    };
    StreamWriter2.prototype.save = function(fileName) {
      if (this.bufferText !== "") {
        this.flush();
      }
      Save.save(fileName, this.buffer);
    };
    StreamWriter2.prototype.write = function(value) {
      if (this.encoding === void 0) {
        throw new Error("Object Disposed Exception: current writer is disposed");
      }
      validateNullOrUndefined(value, "string");
      this.bufferText += value;
      if (this.bufferText.length >= 10240) {
        this.flush();
      }
    };
    StreamWriter2.prototype.flush = function() {
      if (this.bufferText === void 0 || this.bufferText === null || this.bufferText.length === 0) {
        return;
      }
      var bufferArray = this.encoding.getBytes(this.bufferText, 0, this.bufferText.length);
      this.bufferText = "";
      this.bufferBlob = new Blob([this.bufferBlob, bufferArray]);
    };
    StreamWriter2.prototype.writeLine = function(value) {
      if (this.encoding === void 0) {
        throw new Error("Object Disposed Exception: current writer is disposed");
      }
      validateNullOrUndefined(value, "string");
      this.bufferText = this.bufferText + value + "\r\n";
      if (this.bufferText.length >= 10240) {
        this.flush();
      }
    };
    StreamWriter2.prototype.destroy = function() {
      this.bufferBlob = void 0;
      this.bufferText = void 0;
      if (this.enc instanceof Encoding) {
        this.enc.destroy();
      }
      this.enc = void 0;
    };
    return StreamWriter2;
  }()
);

// node_modules/@syncfusion/ej2-compression/src/compression-writer.js
var ARR_LITERAL_CODES = new Int16Array(286);
var ARR_LITERAL_LENGTHS = new Uint8Array(286);
var ARR_DISTANCE_CODES = new Int16Array(30);
var ARR_DISTANCE_LENGTHS = new Uint8Array(30);
var CompressedStreamWriter = (
  /** @class */
  function() {
    function CompressedStreamWriter2(noWrap) {
      this.pendingBuffer = new Uint8Array(1 << 16);
      this.pendingBufLength = 0;
      this.pendingBufCache = 0;
      this.pendingBufBitsInCache = 0;
      this.bufferPosition = 0;
      this.extraBits = 0;
      this.currentHash = 0;
      this.matchStart = 0;
      this.matchLength = 0;
      this.matchPrevAvail = false;
      this.blockStart = 0;
      this.stringStart = 0;
      this.lookAhead = 0;
      this.totalBytesIn = 0;
      this.inputOffset = 0;
      this.inputEnd = 0;
      this.windowSize = 1 << 15;
      this.windowMask = this.windowSize - 1;
      this.hashSize = 1 << 15;
      this.hashMask = this.hashSize - 1;
      this.hashShift = Math.floor((15 + 3 - 1) / 3);
      this.maxDist = this.windowSize - 262;
      this.checkSum = 1;
      this.noWrap = false;
      if (!CompressedStreamWriter2.isHuffmanTreeInitiated) {
        CompressedStreamWriter2.initHuffmanTree();
        CompressedStreamWriter2.isHuffmanTreeInitiated = true;
      }
      this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);
      this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);
      this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);
      this.arrDistances = new Uint16Array(1 << 14);
      this.arrLiterals = new Uint8Array(1 << 14);
      this.stream = [];
      this.dataWindow = new Uint8Array(2 * this.windowSize);
      this.hashHead = new Int16Array(this.hashSize);
      this.hashPrevious = new Int16Array(this.windowSize);
      this.blockStart = this.stringStart = 1;
      this.noWrap = noWrap;
      if (!noWrap) {
        this.writeZLibHeader();
      }
    }
    Object.defineProperty(CompressedStreamWriter2.prototype, "compressedData", {
      /**
       * get compressed data
       */
      get: function() {
        return this.stream;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompressedStreamWriter2.prototype, "getCompressedString", {
      get: function() {
        var compressedString = "";
        if (this.stream !== void 0) {
          for (var i = 0; i < this.stream.length; i++) {
            compressedString += String.fromCharCode.apply(null, this.stream[i]);
          }
        }
        return compressedString;
      },
      enumerable: true,
      configurable: true
    });
    CompressedStreamWriter2.prototype.write = function(data, offset, length) {
      if (data === void 0 || data === null) {
        throw new Error("ArgumentException: data cannot null or undefined");
      }
      var end = offset + length;
      if (0 > offset || offset > end || end > data.length) {
        throw new Error("ArgumentOutOfRangeException: Offset or length is incorrect");
      }
      if (typeof data === "string") {
        var encode = new Encoding(false);
        encode.type = "Utf8";
        data = new Uint8Array(encode.getBytes(data, 0, data.length));
        end = offset + data.length;
      }
      this.inputBuffer = data;
      this.inputOffset = offset;
      this.inputEnd = end;
      if (!this.noWrap) {
        this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);
      }
      while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {
        this.pendingBufferFlush();
        this.compressData(false);
      }
    };
    CompressedStreamWriter2.prototype.writeZLibHeader = function() {
      var headerDate = 8 + (7 << 4) << 8;
      headerDate |= (5 >> 2 & 3) << 6;
      headerDate += 31 - headerDate % 31;
      this.pendingBufferWriteShortBytes(headerDate);
    };
    CompressedStreamWriter2.prototype.pendingBufferWriteShortBytes = function(s) {
      this.pendingBuffer[this.pendingBufLength++] = s >> 8;
      this.pendingBuffer[this.pendingBufLength++] = s;
    };
    CompressedStreamWriter2.prototype.compressData = function(finish) {
      var success;
      do {
        this.fillWindow();
        var canFlush = finish && this.inputEnd === this.inputOffset;
        success = this.compressSlow(canFlush, finish);
      } while (this.pendingBufLength === 0 && success);
      return success;
    };
    CompressedStreamWriter2.prototype.compressSlow = function(flush, finish) {
      if (this.lookAhead < 262 && !flush) {
        return false;
      }
      while (this.lookAhead >= 262 || flush) {
        if (this.lookAhead === 0) {
          return this.lookAheadCompleted(finish);
        }
        if (this.stringStart >= 2 * this.windowSize - 262) {
          this.slideWindow();
        }
        var prevMatch = this.matchStart;
        var prevLen = this.matchLength;
        if (this.lookAhead >= 3) {
          this.discardMatch();
        }
        if (prevLen >= 3 && this.matchLength <= prevLen) {
          prevLen = this.matchPreviousBest(prevMatch, prevLen);
        } else {
          this.matchPreviousAvailable();
        }
        if (this.bufferPosition >= 1 << 14) {
          return this.huffmanIsFull(finish);
        }
      }
      return true;
    };
    CompressedStreamWriter2.prototype.discardMatch = function() {
      var hashHead = this.insertString();
      if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {
        if (this.matchLength <= 5 && (this.matchLength === 3 && this.stringStart - this.matchStart > 4096)) {
          this.matchLength = 3 - 1;
        }
      }
    };
    CompressedStreamWriter2.prototype.matchPreviousAvailable = function() {
      if (this.matchPrevAvail) {
        this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 255);
      }
      this.matchPrevAvail = true;
      this.stringStart++;
      this.lookAhead--;
    };
    CompressedStreamWriter2.prototype.matchPreviousBest = function(prevMatch, prevLen) {
      this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);
      prevLen -= 2;
      do {
        this.stringStart++;
        this.lookAhead--;
        if (this.lookAhead >= 3) {
          this.insertString();
        }
      } while (--prevLen > 0);
      this.stringStart++;
      this.lookAhead--;
      this.matchPrevAvail = false;
      this.matchLength = 3 - 1;
      return prevLen;
    };
    CompressedStreamWriter2.prototype.lookAheadCompleted = function(finish) {
      if (this.matchPrevAvail) {
        this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 255);
      }
      this.matchPrevAvail = false;
      this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);
      this.blockStart = this.stringStart;
      return false;
    };
    CompressedStreamWriter2.prototype.huffmanIsFull = function(finish) {
      var len = this.stringStart - this.blockStart;
      if (this.matchPrevAvail) {
        len--;
      }
      var lastBlock = finish && this.lookAhead === 0 && !this.matchPrevAvail;
      this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);
      this.blockStart += len;
      return !lastBlock;
    };
    CompressedStreamWriter2.prototype.fillWindow = function() {
      if (this.stringStart >= this.windowSize + this.maxDist) {
        this.slideWindow();
      }
      while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {
        var more = 2 * this.windowSize - this.lookAhead - this.stringStart;
        if (more > this.inputEnd - this.inputOffset) {
          more = this.inputEnd - this.inputOffset;
        }
        this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);
        this.inputOffset += more;
        this.totalBytesIn += more;
        this.lookAhead += more;
      }
      if (this.lookAhead >= 3) {
        this.updateHash();
      }
    };
    CompressedStreamWriter2.prototype.slideWindow = function() {
      this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);
      this.matchStart -= this.windowSize;
      this.stringStart -= this.windowSize;
      this.blockStart -= this.windowSize;
      for (var i = 0; i < this.hashSize; ++i) {
        var m = this.hashHead[i] & 65535;
        this.hashHead[i] = m >= this.windowSize ? m - this.windowSize : 0;
      }
      for (var i = 0; i < this.windowSize; i++) {
        var m = this.hashPrevious[i] & 65535;
        this.hashPrevious[i] = m >= this.windowSize ? m - this.windowSize : 0;
      }
    };
    CompressedStreamWriter2.prototype.insertString = function() {
      var match;
      var hash = (this.currentHash << this.hashShift ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;
      this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];
      this.hashHead[hash] = this.stringStart;
      this.currentHash = hash;
      return match & 65535;
    };
    CompressedStreamWriter2.prototype.findLongestMatch = function(curMatch) {
      var chainLen = 4096;
      var niceLen = 258;
      var scan = this.stringStart;
      var match;
      var bestEnd = this.stringStart + this.matchLength;
      var bestLength = Math.max(this.matchLength, 3 - 1);
      var limit = Math.max(this.stringStart - this.maxDist, 0);
      var stringEnd = this.stringStart + 258 - 1;
      var scanEnd1 = this.dataWindow[bestEnd - 1];
      var scanEnd = this.dataWindow[bestEnd];
      var data = this.dataWindow;
      if (bestLength >= 32) {
        chainLen >>= 2;
      }
      if (niceLen > this.lookAhead) {
        niceLen = this.lookAhead;
      }
      do {
        if (data[curMatch + bestLength] !== scanEnd || data[curMatch + bestLength - 1] !== scanEnd1 || data[curMatch] !== data[scan] || data[curMatch + 1] !== data[scan + 1]) {
          continue;
        }
        match = curMatch + 2;
        scan += 2;
        while (data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {
        }
        if (scan > bestEnd) {
          this.matchStart = curMatch;
          bestEnd = scan;
          bestLength = scan - this.stringStart;
          if (bestLength >= niceLen) {
            break;
          }
          scanEnd1 = data[bestEnd - 1];
          scanEnd = data[bestEnd];
        }
        scan = this.stringStart;
      } while ((curMatch = this.hashPrevious[curMatch & this.windowMask] & 65535) > limit && --chainLen !== 0);
      this.matchLength = Math.min(bestLength, this.lookAhead);
      return this.matchLength >= 3;
    };
    CompressedStreamWriter2.prototype.updateHash = function() {
      this.currentHash = this.dataWindow[this.stringStart] << this.hashShift ^ this.dataWindow[this.stringStart + 1];
    };
    CompressedStreamWriter2.prototype.huffmanTallyLit = function(literal) {
      this.arrDistances[this.bufferPosition] = 0;
      this.arrLiterals[this.bufferPosition++] = literal;
      this.treeLiteral.codeFrequencies[literal]++;
      return this.bufferPosition >= 1 << 14;
    };
    CompressedStreamWriter2.prototype.huffmanTallyDist = function(dist, len) {
      this.arrDistances[this.bufferPosition] = dist;
      this.arrLiterals[this.bufferPosition++] = len - 3;
      var lc = this.huffmanLengthCode(len - 3);
      this.treeLiteral.codeFrequencies[lc]++;
      if (lc >= 265 && lc < 285) {
        this.extraBits += Math.floor((lc - 261) / 4);
      }
      var dc = this.huffmanDistanceCode(dist - 1);
      this.treeDistances.codeFrequencies[dc]++;
      if (dc >= 4) {
        this.extraBits += Math.floor(dc / 2 - 1);
      }
      return this.bufferPosition >= 1 << 14;
    };
    CompressedStreamWriter2.prototype.huffmanFlushBlock = function(stored, storedOffset, storedLength, lastBlock) {
      this.treeLiteral.codeFrequencies[256]++;
      this.treeLiteral.buildTree();
      this.treeDistances.buildTree();
      this.treeLiteral.calculateBLFreq(this.treeCodeLengths);
      this.treeDistances.calculateBLFreq(this.treeCodeLengths);
      this.treeCodeLengths.buildTree();
      var blTreeCodes = 4;
      for (var i = 18; i > blTreeCodes; i--) {
        if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {
          blTreeCodes = i + 1;
        }
      }
      var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() + this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;
      var static_len = this.extraBits;
      for (var i = 0; i < 286; i++) {
        static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];
      }
      for (var i = 0; i < 30; i++) {
        static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];
      }
      if (opt_len >= static_len) {
        opt_len = static_len;
      }
      if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {
        this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);
      } else if (opt_len == static_len) {
        this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);
        this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);
        this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);
        this.huffmanCompressBlock();
        this.huffmanReset();
      } else {
        this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);
        this.huffmanSendAllTrees(blTreeCodes);
        this.huffmanCompressBlock();
        this.huffmanReset();
      }
    };
    CompressedStreamWriter2.prototype.huffmanFlushStoredBlock = function(stored, storedOffset, storedLength, lastBlock) {
      this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);
      this.pendingBufferAlignToByte();
      this.pendingBufferWriteShort(storedLength);
      this.pendingBufferWriteShort(~storedLength);
      this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);
      this.huffmanReset();
    };
    CompressedStreamWriter2.prototype.huffmanLengthCode = function(len) {
      if (len === 255) {
        return 285;
      }
      var code = 257;
      while (len >= 8) {
        code += 4;
        len >>= 1;
      }
      return code + len;
    };
    CompressedStreamWriter2.prototype.huffmanDistanceCode = function(distance) {
      var code = 0;
      while (distance >= 4) {
        code += 2;
        distance >>= 1;
      }
      return code + distance;
    };
    CompressedStreamWriter2.prototype.huffmanSendAllTrees = function(blTreeCodes) {
      this.treeCodeLengths.buildCodes();
      this.treeLiteral.buildCodes();
      this.treeDistances.buildCodes();
      this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);
      this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);
      this.pendingBufferWriteBits(blTreeCodes - 4, 4);
      for (var rank = 0; rank < blTreeCodes; rank++) {
        this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);
      }
      this.treeLiteral.writeTree(this.treeCodeLengths);
      this.treeDistances.writeTree(this.treeCodeLengths);
    };
    CompressedStreamWriter2.prototype.huffmanReset = function() {
      this.bufferPosition = 0;
      this.extraBits = 0;
      this.treeLiteral.reset();
      this.treeDistances.reset();
      this.treeCodeLengths.reset();
    };
    CompressedStreamWriter2.prototype.huffmanCompressBlock = function() {
      for (var i = 0; i < this.bufferPosition; i++) {
        var literalLen = this.arrLiterals[i] & 255;
        var dist = this.arrDistances[i];
        if (dist-- !== 0) {
          var lc = this.huffmanLengthCode(literalLen);
          this.treeLiteral.writeCodeToStream(lc);
          var bits = Math.floor((lc - 261) / 4);
          if (bits > 0 && bits <= 5) {
            this.pendingBufferWriteBits(literalLen & (1 << bits) - 1, bits);
          }
          var dc = this.huffmanDistanceCode(dist);
          this.treeDistances.writeCodeToStream(dc);
          bits = Math.floor(dc / 2 - 1);
          if (bits > 0) {
            this.pendingBufferWriteBits(dist & (1 << bits) - 1, bits);
          }
        } else {
          this.treeLiteral.writeCodeToStream(literalLen);
        }
      }
      this.treeLiteral.writeCodeToStream(256);
    };
    CompressedStreamWriter2.prototype.pendingBufferWriteBits = function(b, count) {
      var uint = new Uint32Array(1);
      uint[0] = this.pendingBufCache | b << this.pendingBufBitsInCache;
      this.pendingBufCache = uint[0];
      this.pendingBufBitsInCache += count;
      this.pendingBufferFlushBits();
    };
    CompressedStreamWriter2.prototype.pendingBufferFlush = function(isClose) {
      this.pendingBufferFlushBits();
      if (this.pendingBufLength > 0) {
        var array = new Uint8Array(this.pendingBufLength);
        array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);
        this.stream.push(array);
      }
      this.pendingBufLength = 0;
    };
    CompressedStreamWriter2.prototype.pendingBufferFlushBits = function() {
      var result = 0;
      while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < 1 << 16) {
        this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;
        this.pendingBufCache >>= 8;
        this.pendingBufBitsInCache -= 8;
        result++;
      }
      return result;
    };
    CompressedStreamWriter2.prototype.pendingBufferWriteByteBlock = function(data, offset, length) {
      var array = data.subarray(offset, offset + length);
      this.pendingBuffer.set(array, this.pendingBufLength);
      this.pendingBufLength += length;
    };
    CompressedStreamWriter2.prototype.pendingBufferWriteShort = function(s) {
      this.pendingBuffer[this.pendingBufLength++] = s;
      this.pendingBuffer[this.pendingBufLength++] = s >> 8;
    };
    CompressedStreamWriter2.prototype.pendingBufferAlignToByte = function() {
      if (this.pendingBufBitsInCache > 0) {
        this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;
      }
      this.pendingBufCache = 0;
      this.pendingBufBitsInCache = 0;
    };
    CompressedStreamWriter2.initHuffmanTree = function() {
      var i = 0;
      while (i < 144) {
        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(48 + i << 8);
        ARR_LITERAL_LENGTHS[i++] = 8;
      }
      while (i < 256) {
        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(400 - 144 + i << 7);
        ARR_LITERAL_LENGTHS[i++] = 9;
      }
      while (i < 280) {
        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0 - 256 + i << 9);
        ARR_LITERAL_LENGTHS[i++] = 7;
      }
      while (i < 286) {
        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(192 - 280 + i << 8);
        ARR_LITERAL_LENGTHS[i++] = 8;
      }
      for (i = 0; i < 30; i++) {
        ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);
        ARR_DISTANCE_LENGTHS[i] = 5;
      }
    };
    CompressedStreamWriter2.prototype.close = function() {
      do {
        this.pendingBufferFlush(true);
        if (!this.compressData(true)) {
          this.pendingBufferFlush(true);
          this.pendingBufferAlignToByte();
          if (!this.noWrap) {
            this.pendingBufferWriteShortBytes(this.checkSum >> 16);
            this.pendingBufferWriteShortBytes(this.checkSum & 65535);
          }
          this.pendingBufferFlush(true);
        }
      } while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0));
    };
    CompressedStreamWriter2.prototype.destroy = function() {
      this.stream = [];
      this.stream = void 0;
      this.pendingBuffer = void 0;
      this.treeLiteral = void 0;
      this.treeDistances = void 0;
      this.treeCodeLengths = void 0;
      this.arrLiterals = void 0;
      this.arrDistances = void 0;
      this.hashHead = void 0;
      this.hashPrevious = void 0;
      this.dataWindow = void 0;
      this.inputBuffer = void 0;
      this.pendingBufLength = void 0;
      this.pendingBufCache = void 0;
      this.pendingBufBitsInCache = void 0;
      this.bufferPosition = void 0;
      this.extraBits = void 0;
      this.currentHash = void 0;
      this.matchStart = void 0;
      this.matchLength = void 0;
      this.matchPrevAvail = void 0;
      this.blockStart = void 0;
      this.stringStart = void 0;
      this.lookAhead = void 0;
      this.totalBytesIn = void 0;
      this.inputOffset = void 0;
      this.inputEnd = void 0;
      this.windowSize = void 0;
      this.windowMask = void 0;
      this.hashSize = void 0;
      this.hashMask = void 0;
      this.hashShift = void 0;
      this.maxDist = void 0;
      this.checkSum = void 0;
      this.noWrap = void 0;
    };
    CompressedStreamWriter2.isHuffmanTreeInitiated = false;
    return CompressedStreamWriter2;
  }()
);
var CompressorHuffmanTree = (
  /** @class */
  function() {
    function CompressorHuffmanTree2(writer, elementCount, minCodes, maxLength) {
      this.writer = writer;
      this.codeMinCount = minCodes;
      this.maxLength = maxLength;
      this.codeFrequency = new Uint16Array(elementCount);
      this.lengthCount = new Int32Array(maxLength);
    }
    Object.defineProperty(CompressorHuffmanTree2.prototype, "treeLength", {
      get: function() {
        return this.codeCount;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompressorHuffmanTree2.prototype, "codeLengths", {
      get: function() {
        return this.codeLength;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompressorHuffmanTree2.prototype, "codeFrequencies", {
      get: function() {
        return this.codeFrequency;
      },
      enumerable: true,
      configurable: true
    });
    CompressorHuffmanTree2.prototype.setStaticCodes = function(codes, lengths) {
      var temp = new Int16Array(codes.length);
      temp.set(codes, 0);
      this.codes = temp;
      var lengthTemp = new Uint8Array(lengths.length);
      lengthTemp.set(lengths, 0);
      this.codeLength = lengthTemp;
    };
    CompressorHuffmanTree2.prototype.reset = function() {
      for (var i = 0; i < this.codeFrequency.length; i++) {
        this.codeFrequency[i] = 0;
      }
      this.codes = void 0;
      this.codeLength = void 0;
    };
    CompressorHuffmanTree2.prototype.writeCodeToStream = function(code) {
      this.writer.pendingBufferWriteBits(this.codes[code] & 65535, this.codeLength[code]);
    };
    CompressorHuffmanTree2.prototype.buildCodes = function() {
      var nextCode = new Int32Array(this.maxLength);
      this.codes = new Int16Array(this.codeCount);
      var code = 0;
      for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {
        nextCode[bitsCount] = code;
        code += this.lengthCount[bitsCount] << 15 - bitsCount;
      }
      for (var i = 0; i < this.codeCount; i++) {
        var bits = this.codeLength[i];
        if (bits > 0) {
          this.codes[i] = CompressorHuffmanTree2.bitReverse(nextCode[bits - 1]);
          nextCode[bits - 1] += 1 << 16 - bits;
        }
      }
    };
    CompressorHuffmanTree2.bitReverse = function(value) {
      return CompressorHuffmanTree2.reverseBits[value & 15] << 12 | CompressorHuffmanTree2.reverseBits[value >> 4 & 15] << 8 | CompressorHuffmanTree2.reverseBits[value >> 8 & 15] << 4 | CompressorHuffmanTree2.reverseBits[value >> 12];
    };
    CompressorHuffmanTree2.prototype.getEncodedLength = function() {
      var len = 0;
      for (var i = 0; i < this.codeFrequency.length; i++) {
        len += this.codeFrequency[i] * this.codeLength[i];
      }
      return len;
    };
    CompressorHuffmanTree2.prototype.calculateBLFreq = function(blTree) {
      var maxCount;
      var minCount;
      var count;
      var curLen = -1;
      var i = 0;
      while (i < this.codeCount) {
        count = 1;
        var nextLen = this.codeLength[i];
        if (nextLen === 0) {
          maxCount = 138;
          minCount = 3;
        } else {
          maxCount = 6;
          minCount = 3;
          if (curLen !== nextLen) {
            blTree.codeFrequency[nextLen]++;
            count = 0;
          }
        }
        curLen = nextLen;
        i++;
        while (i < this.codeCount && curLen === this.codeLength[i]) {
          i++;
          if (++count >= maxCount) {
            break;
          }
        }
        if (count < minCount) {
          blTree.codeFrequency[curLen] += count;
        } else if (curLen !== 0) {
          blTree.codeFrequency[16]++;
        } else if (count <= 10) {
          blTree.codeFrequency[17]++;
        } else {
          blTree.codeFrequency[18]++;
        }
      }
    };
    CompressorHuffmanTree2.prototype.writeTree = function(blTree) {
      var maxRepeatCount;
      var minRepeatCount;
      var currentRepeatCount;
      var currentCodeLength = -1;
      var i = 0;
      while (i < this.codeCount) {
        currentRepeatCount = 1;
        var nextLen = this.codeLength[i];
        if (nextLen === 0) {
          maxRepeatCount = 138;
          minRepeatCount = 3;
        } else {
          maxRepeatCount = 6;
          minRepeatCount = 3;
          if (currentCodeLength !== nextLen) {
            blTree.writeCodeToStream(nextLen);
            currentRepeatCount = 0;
          }
        }
        currentCodeLength = nextLen;
        i++;
        while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {
          i++;
          if (++currentRepeatCount >= maxRepeatCount) {
            break;
          }
        }
        if (currentRepeatCount < minRepeatCount) {
          while (currentRepeatCount-- > 0) {
            blTree.writeCodeToStream(currentCodeLength);
          }
        } else if (currentCodeLength !== 0) {
          blTree.writeCodeToStream(16);
          this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);
        } else if (currentRepeatCount <= 10) {
          blTree.writeCodeToStream(17);
          this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);
        } else {
          blTree.writeCodeToStream(18);
          this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);
        }
      }
    };
    CompressorHuffmanTree2.prototype.buildTree = function() {
      var codesCount = this.codeFrequency.length;
      var arrTree = new Int32Array(codesCount);
      var treeLength = 0;
      var maxCount = 0;
      for (var n = 0; n < codesCount; n++) {
        var freq = this.codeFrequency[n];
        if (freq !== 0) {
          var pos = treeLength++;
          var pPos = 0;
          while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {
            arrTree[pos] = arrTree[pPos];
            pos = pPos;
          }
          arrTree[pos] = n;
          maxCount = n;
        }
      }
      while (treeLength < 2) {
        arrTree[treeLength++] = maxCount < 2 ? ++maxCount : 0;
      }
      this.codeCount = Math.max(maxCount + 1, this.codeMinCount);
      var leafsCount = treeLength;
      var nodesCount = leafsCount;
      var child = new Int32Array(4 * treeLength - 2);
      var values = new Int32Array(2 * treeLength - 1);
      for (var i = 0; i < treeLength; i++) {
        var node = arrTree[i];
        var iIndex = 2 * i;
        child[iIndex] = node;
        child[iIndex + 1] = -1;
        values[i] = this.codeFrequency[node] << 8;
        arrTree[i] = i;
      }
      this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);
      this.buildLength(child);
    };
    CompressorHuffmanTree2.prototype.constructHuffmanTree = function(arrTree, treeLength, values, nodesCount, child) {
      do {
        var first = arrTree[0];
        var last = arrTree[--treeLength];
        var lastVal = values[last];
        var pPos = 0;
        var path = 1;
        while (path < treeLength) {
          if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {
            path++;
          }
          arrTree[pPos] = arrTree[path];
          pPos = path;
          path = pPos * 2 + 1;
        }
        while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {
          arrTree[path] = arrTree[pPos];
        }
        arrTree[path] = last;
        var second = arrTree[0];
        last = nodesCount++;
        child[2 * last] = first;
        child[2 * last + 1] = second;
        var minDepth = Math.min(values[first] & 255, values[second] & 255);
        values[last] = lastVal = values[first] + values[second] - minDepth + 1;
        pPos = 0;
        path = 1;
        while (path < treeLength) {
          if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {
            path++;
          }
          arrTree[pPos] = arrTree[path];
          pPos = path;
          path = pPos * 2 + 1;
        }
        while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {
          arrTree[path] = arrTree[pPos];
        }
        arrTree[path] = last;
      } while (treeLength > 1);
    };
    CompressorHuffmanTree2.prototype.buildLength = function(child) {
      this.codeLength = new Uint8Array(this.codeFrequency.length);
      var numNodes = Math.floor(child.length / 2);
      var numLeafs = Math.floor((numNodes + 1) / 2);
      var overflow = 0;
      for (var i = 0; i < this.maxLength; i++) {
        this.lengthCount[i] = 0;
      }
      overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);
      if (overflow === 0) {
        return;
      }
      var iIncreasableLength = this.maxLength - 1;
      do {
        while (this.lengthCount[--iIncreasableLength] === 0) {
        }
        do {
          this.lengthCount[iIncreasableLength]--;
          this.lengthCount[++iIncreasableLength]++;
          overflow -= 1 << this.maxLength - 1 - iIncreasableLength;
        } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);
      } while (overflow > 0);
      this.recreateTree(child, overflow, numLeafs);
    };
    CompressorHuffmanTree2.prototype.recreateTree = function(child, overflow, numLeafs) {
      this.lengthCount[this.maxLength - 1] += overflow;
      this.lengthCount[this.maxLength - 2] -= overflow;
      var nodePtr = 2 * numLeafs;
      for (var bits = this.maxLength; bits !== 0; bits--) {
        var n = this.lengthCount[bits - 1];
        while (n > 0) {
          var childPtr = 2 * child[nodePtr++];
          if (child[childPtr + 1] === -1) {
            this.codeLength[child[childPtr]] = bits;
            n--;
          }
        }
      }
    };
    CompressorHuffmanTree2.prototype.calculateOptimalCodeLength = function(child, overflow, numNodes) {
      var lengths = new Int32Array(numNodes);
      lengths[numNodes - 1] = 0;
      for (var i = numNodes - 1; i >= 0; i--) {
        var childIndex = 2 * i + 1;
        if (child[childIndex] !== -1) {
          var bitLength = lengths[i] + 1;
          if (bitLength > this.maxLength) {
            bitLength = this.maxLength;
            overflow++;
          }
          lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;
        } else {
          var bitLength = lengths[i];
          this.lengthCount[bitLength - 1]++;
          this.codeLength[child[childIndex - 1]] = lengths[i];
        }
      }
      return overflow;
    };
    CompressorHuffmanTree2.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];
    CompressorHuffmanTree2.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    return CompressorHuffmanTree2;
  }()
);
var ChecksumCalculator = (
  /** @class */
  function() {
    function ChecksumCalculator3() {
    }
    ChecksumCalculator3.checksumUpdate = function(checksum, buffer, offset, length) {
      var uint = new Uint32Array(1);
      uint[0] = checksum;
      var checksum_uint = uint[0];
      var s1 = uint[0] = checksum_uint & 65535;
      var s2 = uint[0] = checksum_uint >> ChecksumCalculator3.checkSumBitOffset;
      while (length > 0) {
        var steps = Math.min(length, ChecksumCalculator3.checksumIterationCount);
        length -= steps;
        while (--steps >= 0) {
          s1 = s1 + (uint[0] = buffer[offset++] & 255);
          s2 = s2 + s1;
        }
        s1 %= ChecksumCalculator3.checksumBase;
        s2 %= ChecksumCalculator3.checksumBase;
      }
      checksum_uint = s2 << ChecksumCalculator3.checkSumBitOffset | s1;
      return checksum_uint;
    };
    ChecksumCalculator3.checkSumBitOffset = 16;
    ChecksumCalculator3.checksumBase = 65521;
    ChecksumCalculator3.checksumIterationCount = 3800;
    return ChecksumCalculator3;
  }()
);

// node_modules/@syncfusion/ej2-compression/src/utils.js
var Utils = (
  /** @class */
  function() {
    function Utils2() {
    }
    Utils2.bitReverse = function(value) {
      return Utils2.reverseBits[value & 15] << 12 | Utils2.reverseBits[value >> 4 & 15] << 8 | Utils2.reverseBits[value >> 8 & 15] << 4 | Utils2.reverseBits[value >> 12];
    };
    Utils2.bitConverterToInt32 = function(value, index) {
      return value[index] | value[index + 1] << 8 | value[index + 2] << 16 | value[index + 3] << 24;
    };
    Utils2.bitConverterToInt16 = function(value, index) {
      return value[index] | value[index + 1] << 8;
    };
    Utils2.bitConverterToUInt32 = function(value) {
      var uint = new Uint32Array(1);
      uint[0] = value;
      return uint[0];
    };
    Utils2.bitConverterToUInt16 = function(value, index) {
      var uint = new Uint16Array(1);
      uint[0] = value[index] | value[index + 1] << 8;
      return uint[0];
    };
    Utils2.bitConverterUintToInt32 = function(value) {
      var uint = new Int32Array(1);
      uint[0] = value;
      return uint[0];
    };
    Utils2.bitConverterInt32ToUint = function(value) {
      var uint = new Uint32Array(1);
      uint[0] = value;
      return uint[0];
    };
    Utils2.bitConverterInt32ToInt16 = function(value) {
      var uint = new Int16Array(1);
      uint[0] = value;
      return uint[0];
    };
    Utils2.byteToString = function(value) {
      var str = "";
      for (var i = 0; i < value.length; i++) {
        str += String.fromCharCode(value[i]);
      }
      return str;
    };
    Utils2.byteIntToString = function(value) {
      var str = "";
      for (var i = 0; i < value.length; i++) {
        str += String.fromCharCode(value[i]);
      }
      return str;
    };
    Utils2.arrayCopy = function(source, sourceIndex, destination, destinationIndex, dataToCopy) {
      var temp = new Uint8Array(source.buffer, sourceIndex);
      var data = temp.subarray(0, dataToCopy);
      destination.set(data, destinationIndex);
    };
    Utils2.mergeArray = function(arrayOne, arrayTwo) {
      var mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);
      mergedArray.set(arrayOne);
      mergedArray.set(arrayTwo, arrayOne.length);
      return mergedArray;
    };
    Utils2.encodedString = function(input) {
      var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var chr1;
      var chr2;
      var chr3;
      var encode1;
      var encode2;
      var encode3;
      var encode4;
      var count = 0;
      var resultIndex = 0;
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var totalLength = input.length * 3 / 4;
      if (input.charAt(input.length - 1) === keyStr.charAt(64)) {
        totalLength--;
      }
      if (input.charAt(input.length - 2) === keyStr.charAt(64)) {
        totalLength--;
      }
      if (totalLength % 1 !== 0) {
        throw new Error("Invalid base64 input, bad content length.");
      }
      var output = new Uint8Array(totalLength | 0);
      while (count < input.length) {
        encode1 = keyStr.indexOf(input.charAt(count++));
        encode2 = keyStr.indexOf(input.charAt(count++));
        encode3 = keyStr.indexOf(input.charAt(count++));
        encode4 = keyStr.indexOf(input.charAt(count++));
        chr1 = encode1 << 2 | encode2 >> 4;
        chr2 = (encode2 & 15) << 4 | encode3 >> 2;
        chr3 = (encode3 & 3) << 6 | encode4;
        output[resultIndex++] = chr1;
        if (encode3 !== 64) {
          output[resultIndex++] = chr2;
        }
        if (encode4 !== 64) {
          output[resultIndex++] = chr3;
        }
      }
      return output;
    };
    Utils2.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];
    Utils2.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    return Utils2;
  }()
);

// node_modules/@syncfusion/ej2-compression/src/decompressor-huffman-tree.js
var DecompressorHuffmanTree = (
  /** @class */
  function() {
    function DecompressorHuffmanTree2(lengths) {
      this.buildTree(lengths);
    }
    DecompressorHuffmanTree2.init = function() {
      var lengths;
      var index;
      lengths = new Uint8Array(288);
      index = 0;
      while (index < 144) {
        lengths[index++] = 8;
      }
      while (index < 256) {
        lengths[index++] = 9;
      }
      while (index < 280) {
        lengths[index++] = 7;
      }
      while (index < 288) {
        lengths[index++] = 8;
      }
      DecompressorHuffmanTree2.m_LengthTree = new DecompressorHuffmanTree2(lengths);
      lengths = new Uint8Array(32);
      index = 0;
      while (index < 32) {
        lengths[index++] = 5;
      }
      DecompressorHuffmanTree2.m_DistanceTree = new DecompressorHuffmanTree2(lengths);
    };
    DecompressorHuffmanTree2.prototype.prepareData = function(blCount, nextCode, lengths) {
      var code = 0;
      var treeSize = 512;
      for (var i = 0; i < lengths.length; i++) {
        var length_1 = lengths[i];
        if (length_1 > 0) {
          blCount[length_1]++;
        }
      }
      for (var bits = 1; bits <= DecompressorHuffmanTree2.MAX_BITLEN; bits++) {
        nextCode[bits] = code;
        code += blCount[bits] << 16 - bits;
        if (bits >= 10) {
          var start = nextCode[bits] & 130944;
          var end = code & 130944;
          treeSize += end - start >> 16 - bits;
        }
      }
      return { "code": code, "treeSize": treeSize };
    };
    DecompressorHuffmanTree2.prototype.treeFromData = function(blCount, nextCode, lengths, code, treeSize) {
      var tree = new Int16Array(treeSize);
      var pointer = 512;
      var increment = 1 << 7;
      for (var bits = DecompressorHuffmanTree2.MAX_BITLEN; bits >= 10; bits--) {
        var end = code & 130944;
        code -= blCount[bits] << 16 - bits;
        var start = code & 130944;
        for (var i = start; i < end; i += increment) {
          tree[Utils.bitReverse(i)] = Utils.bitConverterInt32ToInt16(-pointer << 4 | bits);
          pointer += 1 << bits - 9;
        }
      }
      for (var i = 0; i < lengths.length; i++) {
        var bits = lengths[i];
        if (bits == 0) {
          continue;
        }
        code = nextCode[bits];
        var revcode = Utils.bitReverse(code);
        if (bits <= 9) {
          do {
            tree[revcode] = Utils.bitConverterInt32ToInt16(i << 4 | bits);
            revcode += 1 << bits;
          } while (revcode < 512);
        } else {
          var subTree = tree[revcode & 511];
          var treeLen = 1 << (subTree & 15);
          subTree = -(subTree >> 4);
          do {
            tree[subTree | revcode >> 9] = Utils.bitConverterInt32ToInt16(i << 4 | bits);
            revcode += 1 << bits;
          } while (revcode < treeLen);
        }
        nextCode[bits] = code + (1 << 16 - bits);
      }
      return tree;
    };
    DecompressorHuffmanTree2.prototype.buildTree = function(lengths) {
      var blCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      var nextCode = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      var prepareData = this.prepareData(blCount, nextCode, lengths);
      this.m_Tree = this.treeFromData(blCount, nextCode, lengths, prepareData.code, prepareData.treeSize);
    };
    DecompressorHuffmanTree2.prototype.unpackSymbol = function(input) {
      var lookahead;
      var symbol;
      if ((lookahead = input.peekBits(9)) >= 0) {
        if ((symbol = this.m_Tree[lookahead]) >= 0) {
          input.skipBits(symbol & 15);
          return symbol >> 4;
        }
        var subtree = -(symbol >> 4);
        var bitlen = symbol & 15;
        if ((lookahead = input.peekBits(bitlen)) >= 0) {
          symbol = this.m_Tree[subtree | lookahead >> 9];
          input.skipBits(symbol & 15);
          return symbol >> 4;
        } else {
          var bits = input.availableBits;
          lookahead = input.peekBits(bits);
          symbol = this.m_Tree[subtree | lookahead >> 9];
          if ((symbol & 15) <= bits) {
            input.skipBits(symbol & 15);
            return symbol >> 4;
          } else {
            return -1;
          }
        }
      } else {
        var bits = input.availableBits;
        lookahead = input.peekBits(bits);
        symbol = this.m_Tree[lookahead];
        if (symbol >= 0 && (symbol & 15) <= bits) {
          input.skipBits(symbol & 15);
          return symbol >> 4;
        } else {
          return -1;
        }
      }
    };
    Object.defineProperty(DecompressorHuffmanTree2, "lengthTree", {
      /// <summary>
      /// GET huffman tree for encoding and decoding lengths.
      /// </summary>
      get: function() {
        return this.m_LengthTree;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DecompressorHuffmanTree2, "distanceTree", {
      /// <summary>
      /// GET huffman tree for encoding and decoding distances.
      /// </summary>
      get: function() {
        return this.m_DistanceTree;
      },
      enumerable: true,
      configurable: true
    });
    DecompressorHuffmanTree2.MAX_BITLEN = 15;
    return DecompressorHuffmanTree2;
  }()
);

// node_modules/@syncfusion/ej2-compression/src/checksum-calculator.js
var ChecksumCalculator2 = (
  /** @class */
  function() {
    function ChecksumCalculator3() {
    }
    ChecksumCalculator3.ChecksumUpdate = function(checksum, buffer, offset, length) {
      var checkSumUInt = checksum;
      var s1 = checkSumUInt & 65535;
      var s2 = checkSumUInt >> this.DEF_CHECKSUM_BIT_OFFSET;
      while (length > 0) {
        var steps = Math.min(length, this.DEF_CHECKSUM_ITERATIONSCOUNT);
        length -= steps;
        while (--steps >= 0) {
          s1 = s1 + (buffer[offset++] & 255);
          s2 = s2 + s1;
        }
        s1 %= this.DEF_CHECKSUM_BASE;
        s2 %= this.DEF_CHECKSUM_BASE;
      }
      checkSumUInt = s2 << this.DEF_CHECKSUM_BIT_OFFSET | s1;
      checksum = checkSumUInt;
    };
    ChecksumCalculator3.ChecksumGenerate = function(buffer, offset, length) {
      var result = 1;
      ChecksumCalculator3.ChecksumUpdate(result, buffer, offset, length);
      return result;
    };
    ChecksumCalculator3.DEF_CHECKSUM_BIT_OFFSET = 16;
    ChecksumCalculator3.DEF_CHECKSUM_BASE = 65521;
    ChecksumCalculator3.DEF_CHECKSUM_ITERATIONSCOUNT = 3800;
    return ChecksumCalculator3;
  }()
);

// node_modules/@syncfusion/ej2-compression/src/compression-reader.js
var CompressedStreamReader = (
  /** @class */
  function() {
    function CompressedStreamReader2(stream, bNoWrap) {
      this.defaultHuffmanDynamicTree = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      this.DEF_HEADER_METHOD_MASK = 15 << 8;
      this.DEF_HEADER_INFO_MASK = 240 << 8;
      this.DEF_HEADER_FLAGS_FCHECK = 31;
      this.DEF_HEADER_FLAGS_FDICT = 32;
      this.DEF_HEADER_FLAGS_FLEVEL = 192;
      this.DEF_MAX_WINDOW_SIZE = 65535;
      this.DEF_HUFFMAN_REPEATE_MAX = 258;
      this.DEF_HUFFMAN_END_BLOCK = 256;
      this.DEF_HUFFMAN_LENGTH_MINIMUMCODE = 257;
      this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE = 285;
      this.DEF_HUFFMAN_DISTANCE_MAXIMUMCODE = 29;
      this.mCheckSum = 1;
      this.tBuffer = 0;
      this.mBufferedBits = 0;
      this.mTempBuffer = new Uint8Array(4);
      this.mBlockBuffer = new Uint8Array(this.DEF_MAX_WINDOW_SIZE);
      this.mbNoWrap = false;
      this.mWindowSize = 0;
      this.mCurrentPosition = 0;
      this.mDataLength = 0;
      this.mbCanReadNextBlock = true;
      this.mbCanReadMoreData = true;
      this.mbCheckSumRead = false;
      if (stream == null) {
        throw new DOMException("stream");
      }
      if (stream.length === 0) {
        throw new DOMException("stream - string can not be empty");
      }
      DecompressorHuffmanTree.init();
      this.mInputStream = new Stream(stream);
      this.mbNoWrap = bNoWrap;
      if (!this.mbNoWrap) {
        this.readZLibHeader();
      }
      this.decodeBlockHeader();
    }
    Object.defineProperty(CompressedStreamReader2.prototype, "mBuffer", {
      get: function() {
        return this.tBuffer;
      },
      set: function(value) {
        this.tBuffer = value;
      },
      enumerable: true,
      configurable: true
    });
    CompressedStreamReader2.prototype.peekBits = function(count) {
      if (count < 0) {
        throw new DOMException("count", "Bits count can not be less than zero.");
      }
      if (count > 32) {
        throw new DOMException("count", "Count of bits is too large.");
      }
      if (this.mBufferedBits < count) {
        this.fillBuffer();
      }
      if (this.mBufferedBits < count) {
        return -1;
      }
      var bitMask = ~(4294967295 << count);
      var result = Utils.bitConverterUintToInt32(this.mBuffer & bitMask);
      return result;
    };
    CompressedStreamReader2.prototype.fillBuffer = function() {
      var length = 4 - (this.mBufferedBits >> 3) - ((this.mBufferedBits & 7) !== 0 ? 1 : 0);
      if (length === 0) {
        return;
      }
      var bytesRead = this.mInputStream.read(this.mTempBuffer, 0, length);
      for (var i = 0; i < bytesRead; i++) {
        this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer | Utils.bitConverterInt32ToUint(this.mTempBuffer[i] << this.mBufferedBits));
        this.mBufferedBits += 8;
      }
    };
    CompressedStreamReader2.prototype.skipBits = function(count) {
      if (count < 0) {
        throw new DOMException("count", "Bits count can not be less than zero.");
      }
      if (count === 0) {
        return;
      }
      if (count >= this.mBufferedBits) {
        count -= this.mBufferedBits;
        this.mBufferedBits = 0;
        this.mBuffer = 0;
        if (count > 0) {
          this.mInputStream.position += count >> 3;
          count &= 7;
          if (count > 0) {
            this.fillBuffer();
            this.mBufferedBits -= count;
            this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);
          }
        }
      } else {
        this.mBufferedBits -= count;
        this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);
      }
    };
    Object.defineProperty(CompressedStreamReader2.prototype, "availableBits", {
      get: function() {
        return this.mBufferedBits;
      },
      enumerable: true,
      configurable: true
    });
    CompressedStreamReader2.prototype.readZLibHeader = function() {
      var header = this.readInt16();
      if (header === -1) {
        throw new DOMException("Header of the stream can not be read.");
      }
      if (header % 31 !== 0) {
        throw new DOMException("Header checksum illegal");
      }
      if ((header & this.DEF_HEADER_METHOD_MASK) !== 8 << 8) {
        throw new DOMException("Unsupported compression method.");
      }
      this.mWindowSize = Math.pow(2, ((header & this.DEF_HEADER_INFO_MASK) >> 12) + 8);
      if (this.mWindowSize > 65535) {
        throw new DOMException("Unsupported window size for deflate compression method.");
      }
      if ((header & this.DEF_HEADER_FLAGS_FDICT) >> 5 === 1) {
        throw new DOMException("Custom dictionary is not supported at the moment.");
      }
    };
    CompressedStreamReader2.prototype.readInt16 = function() {
      var result = this.readBits(8) << 8;
      result |= this.readBits(8);
      return result;
    };
    CompressedStreamReader2.prototype.readBits = function(count) {
      var result = this.peekBits(count);
      if (result === -1) {
        return -1;
      }
      this.mBufferedBits -= count;
      this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);
      return result;
    };
    CompressedStreamReader2.prototype.decodeBlockHeader = function() {
      if (!this.mbCanReadNextBlock) {
        return false;
      }
      var bFinalBlock = this.readBits(1);
      if (bFinalBlock === -1) {
        return false;
      }
      var blockType = this.readBits(2);
      if (blockType === -1) {
        return false;
      }
      this.mbCanReadNextBlock = bFinalBlock === 0;
      switch (blockType) {
        case 0:
          this.mbReadingUncompressed = true;
          this.skipToBoundary();
          var length_1 = this.readInt16Inverted();
          var lengthComplement = this.readInt16Inverted();
          if (length_1 !== (lengthComplement ^ 65535)) {
            throw new DOMException("Wrong block length.");
          }
          if (length_1 > 65535) {
            throw new DOMException("Uncompressed block length can not be more than 65535.");
          }
          this.mUncompressedDataLength = length_1;
          this.mCurrentLengthTree = null;
          this.mCurrentDistanceTree = null;
          break;
        case 1:
          this.mbReadingUncompressed = false;
          this.mUncompressedDataLength = -1;
          this.mCurrentLengthTree = DecompressorHuffmanTree.lengthTree;
          this.mCurrentDistanceTree = DecompressorHuffmanTree.distanceTree;
          break;
        case 2:
          this.mbReadingUncompressed = false;
          this.mUncompressedDataLength = -1;
          var trees = this.decodeDynamicHeader(this.mCurrentLengthTree, this.mCurrentDistanceTree);
          this.mCurrentLengthTree = trees.lengthTree;
          this.mCurrentDistanceTree = trees.distanceTree;
          break;
        default:
          throw new DOMException("Wrong block type.");
      }
      return true;
    };
    CompressedStreamReader2.prototype.skipToBoundary = function() {
      this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> (this.mBufferedBits & 7));
      this.mBufferedBits &= ~7;
    };
    CompressedStreamReader2.prototype.readInt16Inverted = function() {
      var result = this.readBits(8);
      result |= this.readBits(8) << 8;
      return result;
    };
    CompressedStreamReader2.prototype.decodeDynamicHeader = function(lengthTree, distanceTree) {
      var bLastSymbol = 0;
      var iLengthsCount = this.readBits(5);
      var iDistancesCount = this.readBits(5);
      var iCodeLengthsCount = this.readBits(4);
      if (iLengthsCount < 0 || iDistancesCount < 0 || iCodeLengthsCount < 0) {
        throw new DOMException("Wrong dynamic huffman codes.");
      }
      iLengthsCount += 257;
      iDistancesCount += 1;
      var iResultingCodeLengthsCount = iLengthsCount + iDistancesCount;
      var arrResultingCodeLengths = new Uint8Array(iResultingCodeLengthsCount);
      var arrDecoderCodeLengths = new Uint8Array(19);
      iCodeLengthsCount += 4;
      var iCurrentCode = 0;
      while (iCurrentCode < iCodeLengthsCount) {
        var len = this.readBits(3);
        if (len < 0) {
          throw new DOMException("Wrong dynamic huffman codes.");
        }
        arrDecoderCodeLengths[this.defaultHuffmanDynamicTree[iCurrentCode++]] = len;
      }
      var treeInternalDecoder = new DecompressorHuffmanTree(arrDecoderCodeLengths);
      iCurrentCode = 0;
      for (; ; ) {
        var symbol = void 0;
        var bNeedBreak = false;
        symbol = treeInternalDecoder.unpackSymbol(this);
        while ((symbol & ~15) === 0) {
          arrResultingCodeLengths[iCurrentCode++] = bLastSymbol = symbol;
          if (iCurrentCode === iResultingCodeLengthsCount) {
            bNeedBreak = true;
            break;
          }
          symbol = treeInternalDecoder.unpackSymbol(this);
        }
        if (bNeedBreak) {
          break;
        }
        if (symbol < 0) {
          throw new DOMException("Wrong dynamic huffman codes.");
        }
        if (symbol >= 17) {
          bLastSymbol = 0;
        } else if (iCurrentCode === 0) {
          throw new DOMException("Wrong dynamic huffman codes.");
        }
        var miRepSymbol = symbol - 16;
        var bits = CompressedStreamReader2.DEF_HUFFMAN_DYNTREE_REPEAT_BITS[miRepSymbol];
        var count = this.readBits(bits);
        if (count < 0) {
          throw new DOMException("Wrong dynamic huffman codes.");
        }
        count += CompressedStreamReader2.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS[miRepSymbol];
        if (iCurrentCode + count > iResultingCodeLengthsCount) {
          throw new DOMException("Wrong dynamic huffman codes.");
        }
        while (count-- > 0) {
          arrResultingCodeLengths[iCurrentCode++] = bLastSymbol;
        }
        if (iCurrentCode === iResultingCodeLengthsCount) {
          break;
        }
      }
      var tempArray = new Uint8Array(iLengthsCount);
      tempArray.set(arrResultingCodeLengths.subarray(0, iLengthsCount), 0);
      lengthTree = new DecompressorHuffmanTree(tempArray);
      tempArray = arrResultingCodeLengths.slice(iLengthsCount, iLengthsCount + iDistancesCount);
      distanceTree = new DecompressorHuffmanTree(tempArray);
      return { "lengthTree": lengthTree, "distanceTree": distanceTree };
    };
    CompressedStreamReader2.prototype.readHuffman = function() {
      var free = this.DEF_MAX_WINDOW_SIZE - (this.mDataLength - this.mCurrentPosition);
      var dataRead = false;
      var readdata = {};
      while (free >= this.DEF_HUFFMAN_REPEATE_MAX) {
        var symbol = void 0;
        symbol = this.mCurrentLengthTree.unpackSymbol(this);
        while ((symbol & ~255) === 0) {
          readdata[(this.mDataLength + 1) % this.DEF_MAX_WINDOW_SIZE] = symbol;
          this.mBlockBuffer[this.mDataLength++ % this.DEF_MAX_WINDOW_SIZE] = symbol;
          dataRead = true;
          if (--free < this.DEF_HUFFMAN_REPEATE_MAX) {
            return true;
          }
          symbol = this.mCurrentLengthTree.unpackSymbol(this);
        }
        if (symbol < this.DEF_HUFFMAN_LENGTH_MINIMUMCODE) {
          if (symbol < this.DEF_HUFFMAN_END_BLOCK) {
            throw new DOMException("Illegal code.");
          }
          var numDataRead = dataRead ? 1 : 0;
          this.mbCanReadMoreData = this.decodeBlockHeader();
          var numReadMore = this.mbCanReadMoreData ? 1 : 0;
          return numDataRead | numReadMore ? true : false;
        }
        if (symbol > this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE) {
          throw new DOMException("Illegal repeat code length.");
        }
        var iRepeatLength = CompressedStreamReader2.DEF_HUFFMAN_REPEAT_LENGTH_BASE[symbol - this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];
        var iRepeatExtraBits = CompressedStreamReader2.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION[symbol - this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];
        if (iRepeatExtraBits > 0) {
          var extra = this.readBits(iRepeatExtraBits);
          if (extra < 0) {
            throw new DOMException("Wrong data.");
          }
          iRepeatLength += extra;
        }
        symbol = this.mCurrentDistanceTree.unpackSymbol(this);
        if (symbol < 0 || symbol > CompressedStreamReader2.DEF_HUFFMAN_REPEAT_DISTANCE_BASE.length) {
          throw new DOMException("Wrong distance code.");
        }
        var iRepeatDistance = CompressedStreamReader2.DEF_HUFFMAN_REPEAT_DISTANCE_BASE[symbol];
        iRepeatExtraBits = CompressedStreamReader2.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION[symbol];
        if (iRepeatExtraBits > 0) {
          var extra = this.readBits(iRepeatExtraBits);
          if (extra < 0) {
            throw new DOMException("Wrong data.");
          }
          iRepeatDistance += extra;
        }
        for (var i = 0; i < iRepeatLength; i++) {
          this.mBlockBuffer[this.mDataLength % this.DEF_MAX_WINDOW_SIZE] = this.mBlockBuffer[(this.mDataLength - iRepeatDistance) % this.DEF_MAX_WINDOW_SIZE];
          this.mDataLength++;
          free--;
        }
        dataRead = true;
      }
      return dataRead;
    };
    CompressedStreamReader2.prototype.read = function(buffer, offset, length) {
      if (buffer == null) {
        throw new DOMException("buffer");
      }
      if (offset < 0 || offset > buffer.length - 1) {
        throw new DOMException("offset", "Offset does not belong to specified buffer.");
      }
      if (length < 0 || length > buffer.length - offset) {
        throw new DOMException("length", "Length is illegal.");
      }
      var initialLength = length;
      while (length > 0) {
        if (this.mCurrentPosition < this.mDataLength) {
          var inBlockPosition = this.mCurrentPosition % this.DEF_MAX_WINDOW_SIZE;
          var dataToCopy = Math.min(this.DEF_MAX_WINDOW_SIZE - inBlockPosition, this.mDataLength - this.mCurrentPosition);
          dataToCopy = Math.min(dataToCopy, length);
          Utils.arrayCopy(this.mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy);
          this.mCurrentPosition += dataToCopy;
          offset += dataToCopy;
          length -= dataToCopy;
        } else {
          if (!this.mbCanReadMoreData) {
            break;
          }
          var oldDataLength = this.mDataLength;
          if (!this.mbReadingUncompressed) {
            if (!this.readHuffman()) {
              break;
            }
          } else {
            if (this.mUncompressedDataLength === 0) {
              this.mbCanReadMoreData = this.decodeBlockHeader();
              if (!this.mbCanReadMoreData) {
                break;
              }
            } else {
              var inBlockPosition = this.mDataLength % this.DEF_MAX_WINDOW_SIZE;
              var dataToRead = Math.min(this.mUncompressedDataLength, this.DEF_MAX_WINDOW_SIZE - inBlockPosition);
              var dataRead = this.readPackedBytes(this.mBlockBuffer, inBlockPosition, dataToRead);
              if (dataToRead !== dataRead) {
                throw new DOMException("Not enough data in stream.");
              }
              this.mUncompressedDataLength -= dataRead;
              this.mDataLength += dataRead;
            }
          }
          if (oldDataLength < this.mDataLength) {
            var start = oldDataLength % this.DEF_MAX_WINDOW_SIZE;
            var end = this.mDataLength % this.DEF_MAX_WINDOW_SIZE;
            if (start < end) {
              this.checksumUpdate(this.mBlockBuffer, start, end - start);
            } else {
              this.checksumUpdate(this.mBlockBuffer, start, this.DEF_MAX_WINDOW_SIZE - start);
              if (end > 0) {
                this.checksumUpdate(this.mBlockBuffer, 0, end);
              }
            }
          }
        }
      }
      if (!this.mbCanReadMoreData && !this.mbCheckSumRead && !this.mbNoWrap) {
        this.skipToBoundary();
        var checkSum = this.readInt32();
        if (checkSum !== this.mCheckSum) {
          throw new DOMException("Checksum check failed.");
        }
        this.mbCheckSumRead = true;
      }
      return initialLength - length;
    };
    CompressedStreamReader2.prototype.readPackedBytes = function(buffer, offset, length) {
      if (buffer == null) {
        throw new DOMException("buffer");
      }
      if (offset < 0 || offset > buffer.length - 1) {
        throw new DOMException('offset", "Offset can not be less than zero or greater than buffer length - 1.');
      }
      if (length < 0) {
        throw new DOMException('length", "Length can not be less than zero.');
      }
      if (length > buffer.length - offset) {
        throw new DOMException('length", "Length is too large.');
      }
      if ((this.mBufferedBits & 7) !== 0) {
        throw new DOMException("Reading of unalligned data is not supported.");
      }
      if (length === 0) {
        return 0;
      }
      var result = 0;
      while (this.mBufferedBits > 0 && length > 0) {
        buffer[offset++] = this.mBuffer;
        this.mBufferedBits -= 8;
        this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> 8);
        length--;
        result++;
      }
      if (length > 0) {
        result += this.mInputStream.read(buffer, offset, length);
      }
      return result;
    };
    CompressedStreamReader2.prototype.readInt32 = function() {
      var result = this.readBits(8) << 24;
      result |= this.readBits(8) << 16;
      result |= this.readBits(8) << 8;
      result |= this.readBits(8);
      return result;
    };
    CompressedStreamReader2.prototype.checksumUpdate = function(buffer, offset, length) {
      ChecksumCalculator2.ChecksumUpdate(this.mCheckSum, buffer, offset, length);
    };
    CompressedStreamReader2.DEF_REVERSE_BITS = new Uint8Array([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]);
    CompressedStreamReader2.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS = [3, 3, 11];
    CompressedStreamReader2.DEF_HUFFMAN_DYNTREE_REPEAT_BITS = [2, 3, 7];
    CompressedStreamReader2.DEF_HUFFMAN_REPEAT_LENGTH_BASE = [
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258
    ];
    CompressedStreamReader2.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      0
    ];
    CompressedStreamReader2.DEF_HUFFMAN_REPEAT_DISTANCE_BASE = [
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577
    ];
    CompressedStreamReader2.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION = [
      0,
      0,
      0,
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11,
      12,
      12,
      13,
      13
    ];
    return CompressedStreamReader2;
  }()
);
var Stream = (
  /** @class */
  function() {
    function Stream2(input) {
      this.position = 0;
      this.inputStream = new Uint8Array(input.buffer);
    }
    Object.defineProperty(Stream2.prototype, "length", {
      get: function() {
        return this.inputStream.buffer.byteLength;
      },
      enumerable: true,
      configurable: true
    });
    Stream2.prototype.read = function(buffer, start, length) {
      var temp = new Uint8Array(this.inputStream.buffer, this.position + start);
      var data = temp.subarray(0, length);
      buffer.set(data, 0);
      this.position += data.byteLength;
      return data.byteLength;
    };
    Stream2.prototype.readByte = function() {
      return this.inputStream[this.position++];
    };
    Stream2.prototype.write = function(inputBuffer, offset, count) {
      Utils.arrayCopy(inputBuffer, 0, this.inputStream, this.position + offset, count);
      this.position += count;
    };
    Stream2.prototype.toByteArray = function() {
      return new Uint8Array(this.inputStream.buffer);
    };
    return Stream2;
  }()
);

// node_modules/@syncfusion/ej2-compression/src/zip-archive.js
var CRC32TABLE = [];
var INT_SIZE = 4;
var SHORT_SIZE = 2;
var CentralDirectoryEndSignature = 101010256;
var CentralDirSizeOffset = 12;
var CentralHeaderSignature = 33639248;
var BufferSize = 4096;
var ZipArchive = (
  /** @class */
  function() {
    function ZipArchive2() {
      if (CRC32TABLE.length === 0) {
        ZipArchive2.initCrc32Table();
      }
      this.files = [];
      this.level = "Normal";
      Save.isMicrosoftBrowser = !!navigator.msSaveBlob;
    }
    Object.defineProperty(ZipArchive2.prototype, "items", {
      get: function() {
        return this.files;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ZipArchive2.prototype, "compressionLevel", {
      /**
       * gets compression level
       */
      get: function() {
        return this.level;
      },
      /**
       * sets compression level
       */
      set: function(level) {
        this.level = level;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ZipArchive2.prototype, "length", {
      /**
       * gets items count
       */
      get: function() {
        if (this.files === void 0) {
          return 0;
        }
        return this.files.length;
      },
      enumerable: true,
      configurable: true
    });
    ZipArchive2.prototype.addItem = function(item) {
      if (item === null || item === void 0) {
        throw new Error("ArgumentException: item cannot be null or undefined");
      }
      for (var i = 0; i < this.files.length; i++) {
        var file = this.files[i];
        if (file instanceof ZipArchiveItem) {
          if (file.name === item.name) {
            throw new Error("item with same name already exist");
          }
        }
      }
      this.files.push(item);
    };
    ZipArchive2.prototype.addDirectory = function(directoryName) {
      if (directoryName === null || directoryName === void 0) {
        throw new Error("ArgumentException: string cannot be null or undefined");
      }
      if (directoryName.length === 0) {
        throw new Error("ArgumentException: string cannot be empty");
      }
      if (directoryName.slice(-1) !== "/") {
        directoryName += "/";
      }
      if (this.files.indexOf(directoryName) !== -1) {
        throw new Error("item with same name already exist");
      }
      this.files.push(directoryName);
    };
    ZipArchive2.prototype.getItem = function(index) {
      if (index >= 0 && index < this.files.length) {
        return this.files[index];
      }
      return void 0;
    };
    ZipArchive2.prototype.contains = function(item) {
      return this.files.indexOf(item) !== -1 ? true : false;
    };
    ZipArchive2.prototype.open = function(base64String) {
      var zipArchive = this;
      var zipByteArray = Utils.encodedString(base64String);
      if (zipByteArray.length == 0)
        throw new DOMException("stream");
      var stream = new Stream(zipByteArray);
      var lCentralDirEndPosition = ZipArchive2.findValueFromEnd(stream, CentralDirectoryEndSignature, 65557);
      if (lCentralDirEndPosition < 0)
        throw new DOMException("Can't locate end of central directory record. Possible wrong file format or archive is corrupt.");
      stream.position = lCentralDirEndPosition + CentralDirSizeOffset;
      var iCentralDirSize = ZipArchive2.ReadInt32(stream);
      var lCentralDirPosition = lCentralDirEndPosition - iCentralDirSize;
      stream.position = lCentralDirPosition;
      this.readCentralDirectoryDataAndExtractItems(stream);
    };
    ZipArchive2.prototype.readCentralDirectoryDataAndExtractItems = function(stream) {
      if (stream == null)
        throw new DOMException("stream");
      var itemHelper;
      while (ZipArchive2.ReadInt32(stream) == CentralHeaderSignature) {
        itemHelper = new ZipArchiveItemHelper();
        itemHelper.readCentralDirectoryData(stream);
        itemHelper;
      }
      itemHelper.readData(stream, itemHelper.checkCrc);
      itemHelper.decompressData();
      this.files.push(new ZipArchiveItem(itemHelper.unCompressedStream.buffer, itemHelper.name));
    };
    ZipArchive2.prototype.save = function(fileName) {
      if (fileName === null || fileName === void 0 || fileName.length === 0) {
        throw new Error("ArgumentException: fileName cannot be null or undefined");
      }
      if (this.files.length === 0) {
        throw new Error("InvalidOperation");
      }
      var zipArchive = this;
      var promise;
      return promise = new Promise(function(resolve, reject) {
        zipArchive.saveInternal(fileName, false).then(function() {
          resolve(zipArchive);
        });
      });
    };
    ZipArchive2.prototype.saveAsBlob = function() {
      var zipArchive = this;
      var promise;
      return promise = new Promise(function(resolve, reject) {
        zipArchive.saveInternal("", true).then(function(blob) {
          resolve(blob);
        });
      });
    };
    ZipArchive2.prototype.saveInternal = function(fileName, skipFileSave) {
      var _this = this;
      var zipArchive = this;
      var promise;
      return promise = new Promise(function(resolve, reject) {
        var zipData = [];
        var dirLength = 0;
        for (var i = 0; i < zipArchive.files.length; i++) {
          var compressedObject = _this.getCompressedData(_this.files[i]);
          compressedObject.then(function(data) {
            dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);
            if (zipData.length === zipArchive.files.length) {
              var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);
              resolve(blob);
            }
          });
        }
      });
    };
    ZipArchive2.prototype.destroy = function() {
      if (this.files !== void 0 && this.files.length > 0) {
        for (var i = 0; i < this.files.length; i++) {
          var file = this.files[i];
          if (file instanceof ZipArchiveItem) {
            file.destroy();
          }
          file = void 0;
        }
        this.files = [];
      }
      this.files = void 0;
      this.level = void 0;
    };
    ZipArchive2.prototype.getCompressedData = function(item) {
      var zipArchive = this;
      var promise = new Promise(function(resolve, reject) {
        if (item instanceof ZipArchiveItem) {
          var reader_1 = new FileReader();
          reader_1.onload = function() {
            var input = new Uint8Array(reader_1.result);
            var data2 = {
              fileName: item.name,
              crc32Value: 0,
              compressedData: [],
              compressedSize: void 0,
              uncompressedDataSize: input.length,
              compressionType: void 0,
              isDirectory: false
            };
            if (zipArchive.level === "Normal") {
              zipArchive.compressData(input, data2, CRC32TABLE);
              var length_1 = 0;
              for (var i = 0; i < data2.compressedData.length; i++) {
                length_1 += data2.compressedData[i].length;
              }
              data2.compressedSize = length_1;
              data2.compressionType = "\b\0";
            } else {
              data2.compressedSize = input.length;
              data2.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);
              data2.compressionType = "\0\0";
              data2.compressedData.push(input);
            }
            resolve(data2);
          };
          reader_1.readAsArrayBuffer(item.data);
        } else {
          var data = {
            fileName: item,
            crc32Value: 0,
            compressedData: "",
            compressedSize: 0,
            uncompressedDataSize: 0,
            compressionType: "\0\0",
            isDirectory: true
          };
          resolve(data);
        }
      });
      return promise;
    };
    ZipArchive2.prototype.compressData = function(input, data, crc32Table) {
      var compressor = new CompressedStreamWriter(true);
      var currentIndex = 0;
      var nextIndex = 0;
      do {
        if (currentIndex >= input.length) {
          compressor.close();
          break;
        }
        nextIndex = Math.min(input.length, currentIndex + 16384);
        var subArray = input.subarray(currentIndex, nextIndex);
        data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);
        compressor.write(subArray, 0, nextIndex - currentIndex);
        currentIndex = nextIndex;
      } while (currentIndex <= input.length);
      data.compressedData = compressor.compressedData;
      compressor.destroy();
    };
    ZipArchive2.prototype.constructZippedObject = function(zipParts, data, dirLength, isDirectory) {
      var extFileAttr = 0;
      var date = /* @__PURE__ */ new Date();
      if (isDirectory) {
        extFileAttr = extFileAttr | 16;
      }
      extFileAttr = extFileAttr | 0 & 63;
      var header = this.writeHeader(data, date);
      var localHeader = "PK" + header + data.fileName;
      var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);
      zipParts.push({ localHeader, centralDir, compressedData: data });
      return dirLength + localHeader.length + data.compressedSize;
    };
    ZipArchive2.prototype.writeHeader = function(data, date) {
      var zipHeader = "";
      zipHeader += "\n\0\0\0";
      zipHeader += data.compressionType;
      zipHeader += this.getBytes(this.getModifiedTime(date), 2);
      zipHeader += this.getBytes(this.getModifiedDate(date), 2);
      zipHeader += this.getBytes(data.crc32Value, 4);
      zipHeader += this.getBytes(data.compressedSize, 4);
      zipHeader += this.getBytes(data.uncompressedDataSize, 4);
      zipHeader += this.getBytes(data.fileName.length, 2);
      zipHeader += this.getBytes(0, 2);
      return zipHeader;
    };
    ZipArchive2.prototype.writeZippedContent = function(fileName, zipData, localDirLen, skipFileSave) {
      var cenDirLen = 0;
      var buffer = [];
      for (var i = 0; i < zipData.length; i++) {
        var item = zipData[i];
        cenDirLen += item.centralDir.length;
        buffer.push(this.getArrayBuffer(item.localHeader));
        while (item.compressedData.compressedData.length) {
          buffer.push(item.compressedData.compressedData.shift().buffer);
        }
      }
      for (var i = 0; i < zipData.length; i++) {
        buffer.push(this.getArrayBuffer(zipData[i].centralDir));
      }
      buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));
      var blob = new Blob(buffer, { type: "application/zip" });
      if (!skipFileSave) {
        Save.save(fileName, blob);
      }
      return blob;
    };
    ZipArchive2.prototype.writeCentralDirectory = function(data, localHeader, offset, externalFileAttribute) {
      var directoryHeader = "PK" + this.getBytes(20, 2) + localHeader + // inherit from file header
      this.getBytes(0, 2) + // comment length
      "\0\0\0\0" + // internal file attributes 
      this.getBytes(externalFileAttribute, 4) + // external file attributes
      this.getBytes(offset, 4) + // local fileHeader relative offset
      data.fileName;
      return directoryHeader;
    };
    ZipArchive2.prototype.writeFooter = function(zipData, centralLength, localLength) {
      var dirEnd = "PK\0\0\0\0" + this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) + this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) + this.getBytes(0, 2);
      return dirEnd;
    };
    ZipArchive2.prototype.getArrayBuffer = function(input) {
      var a = new Uint8Array(input.length);
      for (var j = 0; j < input.length; ++j) {
        a[j] = input.charCodeAt(j) & 255;
      }
      return a.buffer;
    };
    ZipArchive2.prototype.getBytes = function(value, offset) {
      var bytes = "";
      for (var i = 0; i < offset; i++) {
        bytes += String.fromCharCode(value & 255);
        value = value >>> 8;
      }
      return bytes;
    };
    ZipArchive2.prototype.getModifiedTime = function(date) {
      var modTime = date.getHours();
      modTime = modTime << 6;
      modTime = modTime | date.getMinutes();
      modTime = modTime << 5;
      return modTime = modTime | date.getSeconds() / 2;
    };
    ZipArchive2.prototype.getModifiedDate = function(date) {
      var modiDate = date.getFullYear() - 1980;
      modiDate = modiDate << 4;
      modiDate = modiDate | date.getMonth() + 1;
      modiDate = modiDate << 5;
      return modiDate = modiDate | date.getDate();
    };
    ZipArchive2.prototype.calculateCrc32Value = function(crc32Value, input, crc32Table) {
      crc32Value ^= -1;
      for (var i = 0; i < input.length; i++) {
        crc32Value = crc32Value >>> 8 ^ crc32Table[(crc32Value ^ input[i]) & 255];
      }
      return crc32Value ^ -1;
    };
    ZipArchive2.initCrc32Table = function() {
      var i;
      for (var j = 0; j < 256; j++) {
        i = j;
        for (var k = 0; k < 8; k++) {
          i = i & 1 ? 3988292384 ^ i >>> 1 : i >>> 1;
        }
        CRC32TABLE[j] = i;
      }
    };
    ZipArchive2.findValueFromEnd = function(stream, value, maxCount) {
      if (stream == null)
        throw new DOMException("stream");
      var lStreamSize = stream.inputStream.buffer.byteLength;
      if (lStreamSize < 4)
        return -1;
      var arrBuffer = new Uint8Array(4);
      var lLastPos = Math.max(0, lStreamSize - maxCount);
      var lCurrentPosition = lStreamSize - 1 - INT_SIZE;
      stream.position = lCurrentPosition;
      stream.read(arrBuffer, 0, INT_SIZE);
      var uiCurValue = arrBuffer[0];
      var bFound = uiCurValue == value;
      if (!bFound) {
        while (lCurrentPosition > lLastPos) {
          uiCurValue <<= 8;
          lCurrentPosition--;
          stream.position = lCurrentPosition;
          uiCurValue += stream.readByte();
          if (uiCurValue == value) {
            bFound = true;
            break;
          }
        }
      }
      return bFound ? lCurrentPosition : -1;
    };
    ZipArchive2.ReadInt32 = function(stream) {
      var buffer = new Uint8Array(INT_SIZE);
      if (stream.read(buffer, 0, INT_SIZE) != INT_SIZE) {
        throw new DOMException("Unable to read value at the specified position - end of stream was reached.");
      }
      return Utils.bitConverterToInt32(buffer, 0);
    };
    ZipArchive2.ReadInt16 = function(stream) {
      var buffer = new Uint8Array(SHORT_SIZE);
      if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {
        throw new DOMException("Unable to read value at the specified position - end of stream was reached.");
      }
      return Utils.bitConverterToInt16(buffer, 0);
    };
    ZipArchive2.ReadUInt16 = function(stream) {
      {
        var buffer = new Uint8Array(SHORT_SIZE);
        if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {
          throw new DOMException("Unable to read value at the specified position - end of stream was reached.");
        }
        return Utils.bitConverterToInt16(buffer, 0);
      }
    };
    return ZipArchive2;
  }()
);
var ZipArchiveItemHelper = (
  /** @class */
  function() {
    function ZipArchiveItemHelper2() {
      this.headerSignature = 67324752;
      this.checkCrc = true;
      this.crc32 = 0;
    }
    ZipArchiveItemHelper2.prototype.readCentralDirectoryData = function(stream) {
      stream.position += 4;
      this.options = ZipArchive.ReadInt16(stream);
      this.compressionMethod = ZipArchive.ReadInt16(stream);
      this.checkCrc = this.compressionMethod != 99;
      var lastModified = ZipArchive.ReadInt32(stream);
      this.crc32 = Utils.bitConverterToUInt32(ZipArchive.ReadInt32(stream));
      this.compressedSize = ZipArchive.ReadInt32(stream);
      this.originalSize = ZipArchive.ReadInt32(stream);
      var iFileNameLength = ZipArchive.ReadInt16(stream);
      var iExtraFieldLenth = ZipArchive.ReadInt16(stream);
      var iCommentLength = ZipArchive.ReadInt16(stream);
      stream.position += 4;
      this.externalAttributes = ZipArchive.ReadInt32(stream);
      this.localHeaderOffset = ZipArchive.ReadInt32(stream);
      var arrBuffer = new Uint8Array(iFileNameLength);
      stream.read(arrBuffer, 0, iFileNameLength);
      var m_strItemName = Utils.byteToString(arrBuffer);
      m_strItemName = m_strItemName.replace("\\", "/");
      this.name = m_strItemName;
      stream.position += iExtraFieldLenth + iCommentLength;
      if (this.options != 0)
        this.options = 0;
    };
    ZipArchiveItemHelper2.prototype.readData = function(stream, checkCrc) {
      if (stream.length == 0)
        throw new DOMException("stream");
      stream.position = this.localHeaderOffset;
      this.checkCrc = checkCrc;
      this.readLocalHeader(stream);
      this.readCompressedData(stream);
    };
    ZipArchiveItemHelper2.prototype.decompressData = function() {
      if (this.compressionMethod == 8) {
        if (this.originalSize > 0) {
          this.decompressDataOld();
        }
      }
    };
    ZipArchiveItemHelper2.prototype.decompressDataOld = function() {
      var reader = new CompressedStreamReader(this.compressedStream, true);
      var decompressedData;
      if (this.originalSize > 0)
        decompressedData = new Stream(new Uint8Array(this.originalSize));
      var arrBuffer = new Uint8Array(BufferSize);
      var iReadBytes;
      var past = new Uint8Array(0);
      while ((iReadBytes = reader.read(arrBuffer, 0, BufferSize)) > 0) {
        decompressedData.write(arrBuffer.subarray(0, iReadBytes), 0, iReadBytes);
      }
      this.unCompressedStream = decompressedData.toByteArray();
      if (this.checkCrc) {
      }
    };
    ZipArchiveItemHelper2.prototype.readLocalHeader = function(stream) {
      if (stream.length == 0)
        throw new DOMException("stream");
      if (ZipArchive.ReadInt32(stream) != this.headerSignature)
        throw new DOMException("Can't find local header signature - wrong file format or file is corrupt.");
      stream.position += 22;
      var iNameLength = ZipArchive.ReadInt16(stream);
      var iExtraLength = ZipArchive.ReadUInt16(stream);
      if (this.compressionMethod == 99) {
      } else if (iExtraLength > 2) {
        stream.position += iNameLength;
        var headerVal = ZipArchive.ReadInt16(stream);
        if (headerVal == 23)
          throw new DOMException("UnSupported");
        else
          stream.position += iExtraLength - 2;
      } else
        stream.position += iNameLength + iExtraLength;
    };
    ZipArchiveItemHelper2.prototype.readCompressedData = function(stream) {
      var dataStream;
      if (this.compressedSize > 0) {
        var iBytesLeft = this.compressedSize;
        dataStream = new Stream(new Uint8Array(iBytesLeft));
        var arrBuffer = new Uint8Array(BufferSize);
        while (iBytesLeft > 0) {
          var iBytesToRead = Math.min(iBytesLeft, BufferSize);
          if (stream.read(arrBuffer, 0, iBytesToRead) != iBytesToRead)
            throw new DOMException("End of file reached - wrong file format or file is corrupt.");
          dataStream.write(arrBuffer.subarray(0, iBytesToRead), 0, iBytesToRead);
          iBytesLeft -= iBytesToRead;
        }
        this.compressedStream = new Uint8Array(dataStream.inputStream);
      } else if (this.compressedSize < 0) {
      } else if (this.compressedSize == 0) {
      }
    };
    return ZipArchiveItemHelper2;
  }()
);
var ZipArchiveItem = (
  /** @class */
  function() {
    function ZipArchiveItem2(data, itemName) {
      if (data === null || data === void 0) {
        throw new Error("ArgumentException: data cannot be null or undefined");
      }
      if (itemName === null || itemName === void 0) {
        throw new Error("ArgumentException: string cannot be null or undefined");
      }
      if (itemName.length === 0) {
        throw new Error("string cannot be empty");
      }
      this.data = data;
      this.name = itemName;
    }
    Object.defineProperty(ZipArchiveItem2.prototype, "dataStream", {
      get: function() {
        return this.decompressedStream;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ZipArchiveItem2.prototype, "name", {
      /**
       * Get the name of archive item
       * @returns string
       */
      get: function() {
        return this.fileName;
      },
      /**
       * Set the name of archive item
       * @param  {string} value
       */
      set: function(value) {
        this.fileName = value;
      },
      enumerable: true,
      configurable: true
    });
    ZipArchiveItem2.prototype.destroy = function() {
      this.fileName = void 0;
      this.data = void 0;
    };
    return ZipArchiveItem2;
  }()
);

export {
  Encoding,
  StreamWriter,
  ZipArchive,
  ZipArchiveItem,
  CompressedStreamWriter
};
//# sourceMappingURL=chunk-MNZ573ZI.js.map
