{
  "version": 3,
  "sources": ["../../@syncfusion/ej2-file-utils/src/save.js", "../../@syncfusion/ej2-file-utils/src/xml-writer.js", "../../@syncfusion/ej2-file-utils/src/encoding.js", "../../@syncfusion/ej2-file-utils/src/stream-writer.js", "../../@syncfusion/ej2-compression/src/compression-writer.js", "../../@syncfusion/ej2-compression/src/utils.js", "../../@syncfusion/ej2-compression/src/decompressor-huffman-tree.js", "../../@syncfusion/ej2-compression/src/checksum-calculator.js", "../../@syncfusion/ej2-compression/src/compression-reader.js", "../../@syncfusion/ej2-compression/src/zip-archive.js"],
  "sourcesContent": ["/**\n * Save class provide method to save file\n * ```typescript\n * let blob : Blob = new Blob([''], { type: 'text/plain' });\n * Save.save('fileName.txt',blob);\n */\nvar Save = /** @class */ (function () {\n    /**\n     * Initialize new instance of {save}\n     */\n    function Save() {\n        // tslint:disable\n    }\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param  {string} fileName- file name to save.\n     * @param  {Blob} buffer- the content to write in file\n     * @param  {boolean} isMicrosoftBrowser- specify whether microsoft browser or not\n     * @returns {void}\n     */\n    Save.save = function (fileName, buffer) {\n        if (fileName === null || fileName === undefined || fileName === '') {\n            throw new Error('ArgumentException: fileName cannot be undefined, null or empty');\n        }\n        var extension = fileName.substring(fileName.lastIndexOf('.') + 1, fileName.length);\n        var mimeType = this.getMimeType(extension);\n        if (mimeType !== '') {\n            buffer = new Blob([buffer], { type: mimeType });\n        }\n        if (this.isMicrosoftBrowser) {\n            navigator.msSaveBlob(buffer, fileName);\n        }\n        else {\n            var downloadLink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n            this.saveInternal(fileName, extension, buffer, downloadLink, 'download' in downloadLink);\n        }\n    };\n    Save.saveInternal = function (fileName, extension, buffer, downloadLink, hasDownloadAttribute) {\n        if (hasDownloadAttribute) {\n            downloadLink.download = fileName;\n            var dataUrl_1 = window.URL.createObjectURL(buffer);\n            downloadLink.href = dataUrl_1;\n            var event_1 = document.createEvent('MouseEvent');\n            event_1.initEvent('click', true, true);\n            downloadLink.dispatchEvent(event_1);\n            setTimeout(function () {\n                window.URL.revokeObjectURL(dataUrl_1);\n                dataUrl_1 = undefined;\n            });\n        }\n        else {\n            if (extension !== 'docx' && extension !== 'xlsx') {\n                var url = window.URL.createObjectURL(buffer);\n                var isPopupBlocked = window.open(url, '_blank');\n                if (!isPopupBlocked) {\n                    window.location.href = url;\n                }\n            }\n            else {\n                var reader_1 = new FileReader();\n                reader_1.onloadend = function () {\n                    var isPopupBlocked = window.open(reader_1.result, '_blank');\n                    if (!isPopupBlocked) {\n                        window.location.href = reader_1.result;\n                    }\n                };\n                reader_1.readAsDataURL(buffer);\n            }\n        }\n    };\n    /**\n     *\n     * @param {string} extension - get mime type of the specified extension\n     * @private\n     */\n    Save.getMimeType = function (extension) {\n        var mimeType = '';\n        switch (extension) {\n            case 'html':\n                mimeType = 'text/html';\n                break;\n            case 'pdf':\n                mimeType = 'application/pdf';\n                break;\n            case 'docx':\n                mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\n                break;\n            case 'xlsx':\n                mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';\n                break;\n            case 'txt':\n                mimeType = 'text/plain';\n                break;\n        }\n        return mimeType;\n    };\n    return Save;\n}());\nexport { Save };\n", "import { Save } from './save';\n/**\n * XmlWriter class provide method to create XML data\n */\nvar XmlWriter = /** @class */ (function () {\n    /**\n     * Initialize new instance of {XmlWriter}\n     */\n    function XmlWriter() {\n        this.contentPos = 0;\n        this.bufferText = '';\n        this.bufferBlob = new Blob([''], { type: 'text/plain' });\n        this.currentState = 'Initial';\n        this.namespaceStack = [];\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[0].set('xmlns', 'http://www.w3.org/2000/xmlns/', 'Special');\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[1].set('xml', 'http://www.w3.org/XML/1998/namespace', 'Special');\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[2].set('', '', 'Implied');\n        this.elementStack = [];\n        this.elementStack.push(new XmlElement());\n        this.elementStack[0].set('', '', '', this.namespaceStack.length - 1);\n        this.attributeStack = [];\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    Object.defineProperty(XmlWriter.prototype, \"buffer\", {\n        /**\n         * Gets the content written to the {XmlWriter} as Blob.\n         * @returns {Blob}\n         */\n        get: function () {\n            this.flush();\n            return this.bufferBlob;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Writes processing instruction with a space between the name and text\n     * @param {string} name - name of the processing instruction\n     * @param {string} text - text to write in the processing instruction\n     * @throws ArgumentException\n     * @throws InvalidArgumentException\n     * @throws InvalidOperationException\n     */\n    XmlWriter.prototype.writeProcessingInstruction = function (name, text) {\n        if (name === undefined || name === null || name.length === 0) {\n            throw new Error('ArgumentException: name should not be undefined, null or empty');\n        }\n        this.checkName(name);\n        if (text === undefined || text === null) {\n            text = '';\n        }\n        if (name.length === 3 && name === 'xml') {\n            if (this.currentState !== 'Initial') {\n                // tslint:disable-next-line:max-line-length\n                throw new Error('InvalidArgumentException: Cannot write XML declaration.WriteStartDocument method has already written it');\n            }\n        }\n        if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        else {\n            this.writeStartDocument();\n            this.writeProcessingInstructionInternal(name, text);\n        }\n    };\n    /**\n     * Writes Xml declaration with version and standalone attribute\n     * @param {boolean} standalone - if true it write standalone=yes else standalone=no\n     * @throws InvalidOperation\n     */\n    XmlWriter.prototype.writeStartDocument = function (standalone) {\n        if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        this.currentState = 'StartDocument';\n        this.rawText('<?xml version=\"1.0\" encoding=\"utf-8');\n        if (standalone !== null && standalone !== undefined) {\n            this.rawText('\" standalone=\"');\n            this.rawText(standalone ? 'yes' : 'no');\n        }\n        this.rawText('\"?>');\n    };\n    /**\n     * Closes any open tag or attribute and write the state back to start\n     */\n    XmlWriter.prototype.writeEndDocument = function () {\n        while (this.elementStack.length - 1 > 0) {\n            this.writeEndElement();\n        }\n        this.currentState = 'EndDocument';\n        this.flush();\n    };\n    /**\n     * Writes the specified start tag and associates it with the given namespace and prefix.\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName -localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @throws ArgumentException\n     * @throws InvalidOperationException\n     */\n    XmlWriter.prototype.writeStartElement = function (prefix, localName, namespace) {\n        if (this.bufferBlob === undefined) {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        if (localName === undefined || localName === null || localName.length === 0) {\n            throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n        }\n        this.checkName(localName);\n        if (this.currentState === 'Initial') {\n            this.writeStartDocument();\n        }\n        if (this.currentState === 'StartElement') {\n            this.startElementContent();\n        }\n        this.currentState = 'StartElement';\n        if (prefix === undefined || prefix === null) {\n            if (namespace !== undefined && namespace !== null) {\n                prefix = this.lookupPrefix(namespace);\n            }\n            if (prefix === undefined || prefix === null) {\n                prefix = '';\n            }\n        }\n        else if (prefix.length > 0) {\n            if (namespace === undefined || namespace === null) {\n                namespace = this.lookupNamespace(prefix);\n            }\n            if (namespace === undefined || namespace === null || (namespace !== undefined && namespace.length === 0)) {\n                throw new Error('ArgumentException: Cannot use a prefix with an empty namespace');\n            }\n        }\n        if (namespace === undefined || namespace === null) {\n            namespace = this.lookupNamespace(prefix);\n        }\n        this.writeStartElementInternal(prefix, localName, namespace);\n    };\n    /**\n     * Closes one element and pop corresponding namespace scope\n     */\n    XmlWriter.prototype.writeEndElement = function () {\n        if (this.currentState === 'StartElement') {\n            this.startElementContent();\n            this.currentState = 'ElementContent';\n        }\n        else if (this.currentState === 'ElementContent') {\n            this.currentState = 'ElementContent';\n        }\n        this.currentState = 'EndElement';\n        var top = this.elementStack.length - 1;\n        this.writeEndElementInternal(this.elementStack[top].prefix, this.elementStack[top].localName);\n        this.namespaceStack.splice(this.elementStack[top].previousTop + 1);\n        this.elementStack.splice(top);\n        if (this.bufferText.length > 10240) {\n            this.flush();\n        }\n    };\n    /**\n     * Writes an element with the specified prefix, local name, namespace URI, and value.\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName - localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @param {string} value - value of element\n     */\n    XmlWriter.prototype.writeElementString = function (prefix, localName, namespace, value) {\n        this.writeStartElement(prefix, localName, namespace);\n        if (value !== undefined && value !== null && value.length !== 0) {\n            this.writeString(value);\n        }\n        this.writeEndElement();\n    };\n    /**\n     * Writes out the attribute with the specified prefix, local name, namespace URI, and value\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName - localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @param {string} value - value of element\n     */\n    XmlWriter.prototype.writeAttributeString = function (prefix, localName, namespace, value) {\n        this.writeStartAttribute(prefix, localName, namespace, value);\n        this.writeStringInternal(value, true);\n        this.writeEndAttribute();\n    };\n    /**\n     * Writes the given text content\n     * @param {string} text - text to write\n     * @throws InvalidOperationException\n     */\n    XmlWriter.prototype.writeString = function (text) {\n        this.writeInternal(text, false);\n    };\n    /**\n     * Write given text as raw data\n     * @param {string} text - text to write\n     * @throws InvalidOperationException\n     */\n    XmlWriter.prototype.writeRaw = function (text) {\n        this.writeInternal(text, true);\n    };\n    XmlWriter.prototype.writeInternal = function (text, isRawString) {\n        if (text === undefined || text === null) {\n            return;\n        }\n        else {\n            if (this.currentState !== 'StartElement' && this.currentState !== 'ElementContent') {\n                throw new Error('InvalidOperationException: Wrong Token');\n            }\n            if (this.currentState === 'StartElement') {\n                this.startElementContent();\n            }\n            this.currentState = 'ElementContent';\n            if (isRawString) {\n                this.rawText(text);\n            }\n            else {\n                this.writeStringInternal(text, false);\n            }\n        }\n    };\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param {string} fileName - file name\n     */\n    XmlWriter.prototype.save = function (fileName) {\n        while (this.elementStack.length - 1 > 0) {\n            this.writeEndElement();\n        }\n        if (this.bufferText !== '') {\n            this.flush();\n        }\n        Save.save(fileName, this.buffer);\n    };\n    /**\n     * Releases the resources used by XmlWriter.\n     */\n    XmlWriter.prototype.destroy = function () {\n        this.bufferBlob = undefined;\n        for (var i = 0; i < this.namespaceStack.length; i++) {\n            this.namespaceStack[i].destroy();\n        }\n        this.namespaceStack = [];\n        for (var i = 0; i < this.elementStack.length; i++) {\n            this.elementStack[i].destroy();\n        }\n        this.elementStack = [];\n        this.bufferText = '';\n        this.contentPos = 0;\n    };\n    XmlWriter.prototype.flush = function () {\n        if (this.bufferBlob === undefined) {\n            return;\n        }\n        this.bufferBlob = new Blob([this.bufferBlob, this.bufferText], { type: 'text/plain' });\n        this.bufferText = '';\n    };\n    XmlWriter.prototype.writeProcessingInstructionInternal = function (name, text) {\n        this.bufferText += '<?';\n        this.rawText(name);\n        if (text.length > 0) {\n            this.bufferText += ' ';\n            text = text.replace(/\\?\\>/g, '? >');\n            this.bufferText += text;\n        }\n        this.bufferText += '?';\n        this.bufferText += '>';\n    };\n    XmlWriter.prototype.writeStartAttribute = function (prefix, localName, namespace, value) {\n        if (localName === undefined || localName === null || localName.length === 0) {\n            if (prefix === 'xmlns') {\n                localName = 'xmlns';\n                prefix = '';\n            }\n            else {\n                throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n            }\n        }\n        if (this.currentState !== 'StartElement') {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        this.checkName(localName);\n        this.writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value);\n    };\n    XmlWriter.prototype.writeStartAttributePrefixAndNameSpace = function (prefix, localName, namespace, value) {\n        if (prefix === undefined || prefix === null) {\n            if (namespace !== undefined && namespace !== null) {\n                if (!(localName === 'xmlns' && namespace === 'http://www.w3.org/2000/xmlns/')) {\n                    prefix = this.lookupPrefix(namespace);\n                }\n            }\n            if (prefix === undefined || prefix === null) {\n                prefix = '';\n            }\n        }\n        if (namespace === undefined || namespace === null) {\n            if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n                namespace = this.lookupNamespace(prefix);\n            }\n            if (namespace === undefined || namespace === null) {\n                namespace = '';\n            }\n        }\n        this.writeStartAttributeSpecialAttribute(prefix, localName, namespace, value);\n    };\n    XmlWriter.prototype.writeStartAttributeSpecialAttribute = function (prefix, localName, namespace, value) {\n        if (prefix.length === 0) {\n            if (localName[0] === 'x' && localName === 'xmlns') {\n                this.skipPushAndWrite(prefix, localName, namespace);\n                this.pushNamespaceExplicit('', value);\n                return;\n            }\n            else if (namespace.length > 0) {\n                prefix = this.lookupPrefix(namespace);\n            }\n        }\n        else {\n            if (prefix[0] === 'x') {\n                if (prefix === 'xmlns') {\n                    this.skipPushAndWrite(prefix, localName, namespace);\n                    this.pushNamespaceExplicit(localName, value);\n                    return;\n                }\n                else if (prefix === 'xml') {\n                    if (localName === 'space' || localName === 'lang') {\n                        this.skipPushAndWrite(prefix, localName, namespace);\n                        return;\n                    }\n                }\n            }\n            if (namespace.length === 0) {\n                prefix = '';\n            }\n        }\n        if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n            this.pushNamespaceImplicit(prefix, namespace);\n        }\n        this.skipPushAndWrite(prefix, localName, namespace);\n    };\n    XmlWriter.prototype.writeEndAttribute = function () {\n        this.currentState = 'StartElement';\n        this.bufferText += '\"';\n    };\n    XmlWriter.prototype.writeStartElementInternal = function (prefix, localName, namespace) {\n        this.bufferText += '<';\n        if (prefix.length > 0) {\n            this.rawText(prefix);\n            this.bufferText += ':';\n        }\n        this.rawText(localName);\n        var top = this.elementStack.length;\n        this.elementStack.push(new XmlElement());\n        this.elementStack[top].set(prefix, localName, namespace, this.namespaceStack.length - 1);\n        this.pushNamespaceImplicit(prefix, namespace);\n        for (var i = 0; i < this.attributeStack.length; i++) {\n            this.attributeStack[i].destroy();\n        }\n        this.attributeStack = [];\n    };\n    XmlWriter.prototype.writeEndElementInternal = function (prefix, localName) {\n        if (this.contentPos !== this.bufferText.length + 1) {\n            this.bufferText += '</';\n            if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n                this.rawText(prefix);\n                this.bufferText += ':';\n            }\n            this.rawText(localName);\n            this.bufferText += '>';\n        }\n        else {\n            this.bufferText = this.bufferText.substring(0, this.bufferText.length - 1);\n            this.bufferText += ' />';\n        }\n    };\n    XmlWriter.prototype.writeStartAttributeInternal = function (prefix, localName, namespaceName) {\n        this.bufferText += ' ';\n        if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n            this.rawText(prefix);\n            this.bufferText += ':';\n        }\n        this.rawText(localName);\n        this.bufferText += '=';\n        this.bufferText += '\"';\n    };\n    XmlWriter.prototype.writeNamespaceDeclaration = function (prefix, namespaceUri) {\n        this.writeStartNamespaceDeclaration(prefix);\n        this.writeStringInternal(namespaceUri, true);\n        this.bufferText += '\"';\n    };\n    XmlWriter.prototype.writeStartNamespaceDeclaration = function (prefix) {\n        if (prefix === undefined || prefix === null || prefix.length === 0) {\n            this.rawText(' xmlns=\\\"');\n        }\n        else {\n            this.rawText(' xmlns:');\n            this.rawText(prefix);\n            this.bufferText += '=';\n            this.bufferText += '\"';\n        }\n    };\n    XmlWriter.prototype.writeStringInternal = function (text, inAttributeValue) {\n        if (text === null || text === undefined) {\n            text = '';\n        }\n        var tempText = '';\n        text = text.replace(/\\&/g, '&amp;');\n        text = text.replace(/\\</g, '&lt;');\n        text = text.replace(/\\>/g, '&gt;');\n        if (inAttributeValue) {\n            text = text.replace(/\\\"/g, '&quot;');\n        }\n        this.bufferText += text;\n        if (!inAttributeValue) {\n            this.contentPos = 0;\n        }\n    };\n    XmlWriter.prototype.startElementContent = function () {\n        var start = this.elementStack[this.elementStack.length - 1].previousTop;\n        for (var i = this.namespaceStack.length - 1; i > start; i--) {\n            if (this.namespaceStack[i].kind === 'NeedToWrite') {\n                this.writeNamespaceDeclaration(this.namespaceStack[i].prefix, this.namespaceStack[i].namespaceUri);\n            }\n        }\n        this.bufferText += '>';\n        this.contentPos = this.bufferText.length + 1;\n    };\n    XmlWriter.prototype.rawText = function (text) {\n        this.bufferText += text;\n    };\n    XmlWriter.prototype.addNamespace = function (prefix, ns, kind) {\n        var top = this.namespaceStack.length;\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[top].set(prefix, ns, kind);\n    };\n    XmlWriter.prototype.lookupPrefix = function (namespace) {\n        for (var i = this.namespaceStack.length - 1; i >= 0; i--) {\n            if (this.namespaceStack[i].namespaceUri === namespace) {\n                return this.namespaceStack[i].prefix;\n            }\n        }\n        return undefined;\n    };\n    XmlWriter.prototype.lookupNamespace = function (prefix) {\n        for (var i = this.namespaceStack.length - 1; i >= 0; i--) {\n            if (this.namespaceStack[i].prefix === prefix) {\n                return this.namespaceStack[i].namespaceUri;\n            }\n        }\n        return undefined;\n    };\n    XmlWriter.prototype.lookupNamespaceIndex = function (prefix) {\n        for (var i = this.namespaceStack.length - 1; i >= 0; i--) {\n            if (this.namespaceStack[i].prefix === prefix) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    XmlWriter.prototype.pushNamespaceImplicit = function (prefix, ns) {\n        var kind;\n        var existingNsIndex = this.lookupNamespaceIndex(prefix);\n        if (existingNsIndex !== -1) {\n            if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n                if (this.namespaceStack[existingNsIndex].namespaceUri !== ns) {\n                    throw new Error('XmlException namespace Uri needs to be the same as the one that is already declared');\n                }\n                return;\n            }\n            else {\n                if (this.namespaceStack[existingNsIndex].kind === 'Special') {\n                    if (prefix === 'xml') {\n                        if (ns !== this.namespaceStack[existingNsIndex].namespaceUri) {\n                            throw new Error('InvalidArgumentException: Xml String');\n                        }\n                        else {\n                            kind = 'Implied';\n                        }\n                    }\n                    else {\n                        throw new Error('InvalidArgumentException: Prefix \"xmlns\" is reserved for use by XML.');\n                    }\n                }\n                else {\n                    kind = (this.namespaceStack[existingNsIndex].namespaceUri === ns) ? 'Implied' : 'NeedToWrite';\n                }\n            }\n        }\n        else {\n            if ((ns === 'http://www.w3.org/XML/1998/namespace' && prefix !== 'xml') ||\n                (ns === 'http://www.w3.org/2000/xmlns/' && prefix !== 'xmlns')) {\n                throw new Error('InvalidArgumentException');\n            }\n            kind = 'NeedToWrite';\n        }\n        this.addNamespace(prefix, ns, kind);\n    };\n    XmlWriter.prototype.pushNamespaceExplicit = function (prefix, ns) {\n        var existingNsIndex = this.lookupNamespaceIndex(prefix);\n        if (existingNsIndex !== -1) {\n            if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n                this.namespaceStack[existingNsIndex].kind = 'Written';\n                return;\n            }\n        }\n        this.addNamespace(prefix, ns, 'Written');\n        return;\n    };\n    XmlWriter.prototype.addAttribute = function (prefix, localName, namespaceName) {\n        var top = this.attributeStack.length;\n        this.attributeStack.push(new XmlAttribute());\n        this.attributeStack[top].set(prefix, localName, namespaceName);\n        for (var i = 0; i < top; i++) {\n            if (this.attributeStack[i].isDuplicate(prefix, localName, namespaceName)) {\n                throw new Error('XmlException: duplicate attribute name');\n            }\n        }\n    };\n    XmlWriter.prototype.skipPushAndWrite = function (prefix, localName, namespace) {\n        this.addAttribute(prefix, localName, namespace);\n        this.writeStartAttributeInternal(prefix, localName, namespace);\n    };\n    XmlWriter.prototype.checkName = function (text) {\n        var format = /[ !@#$%^&*()+\\=\\[\\]{};':\"\\\\|,<>\\/?]/;\n        if (format.test(text)) {\n            throw new Error('InvalidArgumentException: invalid name character');\n        }\n    };\n    return XmlWriter;\n}());\nexport { XmlWriter };\n/**\n * class for managing namespace collection\n */\nvar Namespace = /** @class */ (function () {\n    function Namespace() {\n    }\n    /**\n     * set value for current namespace instance\n     * @param {string} prefix namespace's prefix\n     * @param {string} namespaceUri namespace URI\n     * @param {string} kind namespace kind\n     */\n    Namespace.prototype.set = function (prefix, namespaceUri, kind) {\n        this.prefix = prefix;\n        this.namespaceUri = namespaceUri;\n        this.kind = kind;\n    };\n    /**\n     * Releases the resources used by Namespace\n     */\n    Namespace.prototype.destroy = function () {\n        this.prefix = undefined;\n        this.namespaceUri = undefined;\n        this.kind = undefined;\n    };\n    return Namespace;\n}());\nexport { Namespace };\n/**\n * class for managing element collection\n */\nvar XmlElement = /** @class */ (function () {\n    function XmlElement() {\n    }\n    /**\n     * set value of current element\n     * @param {string} prefix - element prefix\n     * @param {string} localName - element local name\n     * @param {string} namespaceUri -namespace URI\n     * @param {string} previousTop - previous namespace top\n     */\n    XmlElement.prototype.set = function (prefix, localName, namespaceUri, previousTop) {\n        this.previousTop = previousTop;\n        this.prefix = prefix;\n        this.namespaceUri = namespaceUri;\n        this.localName = localName;\n    };\n    /**\n     * Releases the resources used by XmlElement\n     */\n    XmlElement.prototype.destroy = function () {\n        this.previousTop = undefined;\n        this.prefix = undefined;\n        this.localName = undefined;\n        this.namespaceUri = undefined;\n    };\n    return XmlElement;\n}());\nexport { XmlElement };\n/**\n * class for managing attribute collection\n */\nvar XmlAttribute = /** @class */ (function () {\n    function XmlAttribute() {\n    }\n    /**\n     * set value of current attribute\n     * @param {string} prefix - namespace's prefix\n     * @param {string} namespaceUri - namespace URI\n     * @param {string} localName - attribute localName\n     */\n    XmlAttribute.prototype.set = function (prefix, localName, namespaceUri) {\n        this.prefix = prefix;\n        this.namespaceUri = namespaceUri;\n        this.localName = localName;\n    };\n    /**\n     * get whether the attribute is duplicate or not\n     * @param {string} prefix - namespace's prefix\n     * @param {string} namespaceUri - namespace URI\n     * @param {string} localName - attribute localName\n     */\n    XmlAttribute.prototype.isDuplicate = function (prefix, localName, namespaceUri) {\n        return ((this.localName === localName) && ((this.prefix === prefix) || (this.namespaceUri === namespaceUri)));\n    };\n    /**\n     * Releases the resources used by XmlAttribute\n     */\n    XmlAttribute.prototype.destroy = function () {\n        this.prefix = undefined;\n        this.namespaceUri = undefined;\n        this.localName = undefined;\n    };\n    return XmlAttribute;\n}());\nexport { XmlAttribute };\n", "/**\n * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).\n * ```typescript\n * let encoding : Encoding = new Encoding();\n * encoding.type = 'Utf8';\n * encoding.getBytes('Encoding', 0, 5);\n * ```\n */\nvar Encoding = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark\n     * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.\n     */\n    function Encoding(includeBom) {\n        this.emitBOM = true;\n        this.encodingType = 'Ansi';\n        this.initBOM(includeBom);\n    }\n    Object.defineProperty(Encoding.prototype, \"includeBom\", {\n        /**\n         * Gets a value indicating whether to write a Unicode byte order mark\n         * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false\n         */\n        get: function () {\n            return this.emitBOM;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Encoding.prototype, \"type\", {\n        /**\n         * Gets the encoding type.\n         * @returns EncodingType\n         */\n        get: function () {\n            return this.encodingType;\n        },\n        /**\n         * Sets the encoding type.\n         * @param  {EncodingType} value\n         */\n        set: function (value) {\n            this.encodingType = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initialize the includeBom to emit BOM or Not\n     * @param  {boolean} includeBom\n     */\n    Encoding.prototype.initBOM = function (includeBom) {\n        if (includeBom === undefined || includeBom === null) {\n            this.emitBOM = true;\n        }\n        else {\n            this.emitBOM = includeBom;\n        }\n    };\n    /**\n     * Calculates the number of bytes produced by encoding the characters in the specified string\n     * @param  {string} chars - The string containing the set of characters to encode\n     * @returns {number} - The number of bytes produced by encoding the specified characters\n     */\n    Encoding.prototype.getByteCount = function (chars) {\n        var byteCount = 0;\n        validateNullOrUndefined(chars, 'string');\n        if (chars === '') {\n            var byte = this.utf8Len(chars.charCodeAt(0));\n            return byte;\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        return this.getByteCountInternal(chars, 0, chars.length);\n    };\n    /**\n     * Return the Byte of character\n     * @param  {number} codePoint\n     * @returns {number}\n     */\n    Encoding.prototype.utf8Len = function (codePoint) {\n        var bytes = codePoint <= 0x7F ? 1 :\n            codePoint <= 0x7FF ? 2 :\n                codePoint <= 0xFFFF ? 3 :\n                    codePoint <= 0x1FFFFF ? 4 : 0;\n        return bytes;\n    };\n    /**\n     * for 4 byte character return surrogate pair true, otherwise false\n     * @param  {number} codeUnit\n     * @returns {boolean}\n     */\n    Encoding.prototype.isHighSurrogate = function (codeUnit) {\n        return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;\n    };\n    /**\n     * for 4byte character generate the surrogate pair\n     * @param  {number} highCodeUnit\n     * @param  {number} lowCodeUnit\n     */\n    Encoding.prototype.toCodepoint = function (highCodeUnit, lowCodeUnit) {\n        highCodeUnit = (0x3FF & highCodeUnit) << 10;\n        var u = highCodeUnit | (0x3FF & lowCodeUnit);\n        return u + 0x10000;\n    };\n    /**\n     * private method to get the byte count for specific charindex and count\n     * @param  {string} chars\n     * @param  {number} charIndex\n     * @param  {number} charCount\n     */\n    Encoding.prototype.getByteCountInternal = function (chars, charIndex, charCount) {\n        var byteCount = 0;\n        if (this.encodingType === 'Utf8' || this.encodingType === 'Unicode') {\n            var isUtf8 = this.encodingType === 'Utf8';\n            for (var i = 0; i < charCount; i++) {\n                var charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);\n                if (this.isHighSurrogate(charCode)) {\n                    if (isUtf8) {\n                        var high = charCode;\n                        var low = chars.charCodeAt(++charIndex);\n                        byteCount += this.utf8Len(this.toCodepoint(high, low));\n                    }\n                    else {\n                        byteCount += 4;\n                        ++i;\n                    }\n                }\n                else {\n                    if (isUtf8) {\n                        byteCount += this.utf8Len(charCode);\n                    }\n                    else {\n                        byteCount += 2;\n                    }\n                }\n                if (isUtf8) {\n                    charIndex++;\n                }\n            }\n            return byteCount;\n        }\n        else {\n            byteCount = charCount;\n            return byteCount;\n        }\n    };\n    /**\n     * Encodes a set of characters from the specified string into the ArrayBuffer.\n     * @param  {string} s- The string containing the set of characters to encode\n     * @param  {number} charIndex-The index of the first character to encode.\n     * @param  {number} charCount- The number of characters to encode.\n     * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.\n     */\n    Encoding.prototype.getBytes = function (s, charIndex, charCount) {\n        validateNullOrUndefined(s, 'string');\n        validateNullOrUndefined(charIndex, 'charIndex');\n        validateNullOrUndefined(charCount, 'charCount');\n        if (charIndex < 0 || charCount < 0) {\n            throw new RangeError('Argument Out Of Range Exception: charIndex or charCount is less than zero');\n        }\n        if (s.length - charIndex < charCount) {\n            throw new RangeError('Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string');\n        }\n        var bytes;\n        if (s === '') {\n            bytes = new ArrayBuffer(0);\n            return bytes;\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        var byteCount = this.getByteCountInternal(s, charIndex, charCount);\n        switch (this.type) {\n            case 'Utf8':\n                bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);\n                return bytes;\n            case 'Unicode':\n                bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);\n                return bytes;\n            default:\n                bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);\n                return bytes;\n        }\n    };\n    /**\n     * Decodes a sequence of bytes from the specified ArrayBuffer into the string.\n     * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.\n     * @param  {number} index- The index of the first byte to decode.\n     * @param  {number} count- The number of bytes to decode.\n     * @returns {string} - The string that contains the resulting set of characters.\n     */\n    Encoding.prototype.getString = function (bytes, index, count) {\n        validateNullOrUndefined(bytes, 'bytes');\n        validateNullOrUndefined(index, 'index');\n        validateNullOrUndefined(count, 'count');\n        if (index < 0 || count < 0) {\n            throw new RangeError('Argument Out Of Range Exception: index or count is less than zero');\n        }\n        if (bytes.byteLength - index < count) {\n            throw new RangeError('Argument Out Of Range Exception: index and count do not denote a valid range in bytes');\n        }\n        if (bytes.byteLength === 0 || count === 0) {\n            return '';\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        var out = '';\n        var byteCal = new Uint8Array(bytes);\n        switch (this.type) {\n            case 'Utf8':\n                var s = this.getStringOfUtf8Encoding(byteCal, index, count);\n                return s;\n            case 'Unicode':\n                var byteUnicode = new Uint16Array(bytes);\n                out = this.getStringofUnicodeEncoding(byteUnicode, index, count);\n                return out;\n            default:\n                var j = index;\n                for (var i = 0; i < count; i++) {\n                    var c = byteCal[j];\n                    out += String.fromCharCode(c); // 1 byte(ASCII) character                  \n                    j++;\n                }\n                return out;\n        }\n    };\n    Encoding.prototype.getBytesOfAnsiEncoding = function (byteCount, s, charIndex, charCount) {\n        var bytes = new ArrayBuffer(byteCount);\n        var bufview = new Uint8Array(bytes);\n        var k = 0;\n        for (var i = 0; i < charCount; i++) {\n            var charcode = s.charCodeAt(charIndex++);\n            if (charcode < 0x800) {\n                bufview[k] = charcode;\n            }\n            else {\n                bufview[k] = 63; //replacement character '?'\n            }\n            k++;\n        }\n        return bytes;\n    };\n    Encoding.prototype.getBytesOfUtf8Encoding = function (byteCount, s, charIndex, charCount) {\n        var bytes = new ArrayBuffer(byteCount);\n        var uint = new Uint8Array(bytes);\n        var index = charIndex;\n        var j = 0;\n        for (var i = 0; i < charCount; i++) {\n            var charcode = s.charCodeAt(index);\n            if (charcode <= 0x7F) { // 1 byte character 2^7\n                uint[j] = charcode;\n            }\n            else if (charcode < 0x800) { // 2 byte character 2^11\n                uint[j] = 0xc0 | (charcode >> 6);\n                uint[++j] = 0x80 | (charcode & 0x3f);\n            }\n            else if ((charcode < 0xd800 || charcode >= 0xe000)) { // 3 byte character 2^16        \n                uint[j] = 0xe0 | (charcode >> 12);\n                uint[++j] = 0x80 | ((charcode >> 6) & 0x3f);\n                uint[++j] = 0x80 | (charcode & 0x3f);\n            }\n            else {\n                uint[j] = 0xef;\n                uint[++j] = 0xbf;\n                uint[++j] = 0xbd; // U+FFFE \"replacement character\"\n            }\n            ++j;\n            ++index;\n        }\n        return bytes;\n    };\n    Encoding.prototype.getBytesOfUnicodeEncoding = function (byteCount, s, charIndex, charCount) {\n        var bytes = new ArrayBuffer(byteCount);\n        var uint16 = new Uint16Array(bytes);\n        for (var i = 0; i < charCount; i++) {\n            var charcode = s.charCodeAt(i);\n            uint16[i] = charcode;\n        }\n        return bytes;\n    };\n    Encoding.prototype.getStringOfUtf8Encoding = function (byteCal, index, count) {\n        var j = 0;\n        var i = index;\n        var s = '';\n        for (j; j < count; j++) {\n            var c = byteCal[i++];\n            while (i > byteCal.length) {\n                return s;\n            }\n            if (c > 127) {\n                if (c > 191 && c < 224 && i < count) {\n                    c = (c & 31) << 6 | byteCal[i] & 63;\n                }\n                else if (c > 223 && c < 240 && i < byteCal.byteLength) {\n                    c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;\n                }\n                else if (c > 239 && c < 248 && i < byteCal.byteLength) {\n                    c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;\n                }\n                ++i;\n            }\n            s += String.fromCharCode(c); // 1 byte(ASCII) character                          \n        }\n        return s;\n    };\n    Encoding.prototype.getStringofUnicodeEncoding = function (byteUni, index, count) {\n        if (count > byteUni.length) {\n            throw new RangeError('ArgumentOutOfRange_Count');\n        }\n        var byte16 = new Uint16Array(count);\n        var out = '';\n        for (var i = 0; i < count && i < byteUni.length; i++) {\n            byte16[i] = byteUni[index++];\n        }\n        out = String.fromCharCode.apply(null, byte16);\n        return out;\n    };\n    /**\n     * To clear the encoding instance\n     * @return {void}\n     */\n    Encoding.prototype.destroy = function () {\n        this.emitBOM = undefined;\n        this.encodingType = undefined;\n    };\n    return Encoding;\n}());\nexport { Encoding };\n/**\n * To check the object is null or undefined and throw error if it is null or undefined\n * @param {Object} value - object to check is null or undefined\n * @return {boolean}\n * @throws {ArgumentException} - if the value is null or undefined\n * @private\n */\nexport function validateNullOrUndefined(value, message) {\n    if (value === null || value === undefined) {\n        throw new Error('ArgumentException: ' + message + ' cannot be null or undefined');\n    }\n}\n", "import { Encoding, validateNullOrUndefined } from './encoding';\nimport { Save } from './save';\n/**\n * StreamWriter class contains the implementation for writing characters to a file in a particular encoding\n * ```typescript\n * let writer = new StreamWriter();\n * writer.write('Hello World');\n * writer.save('Sample.txt');\n * writer.dispose();\n * ```\n */\nvar StreamWriter = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the StreamWriter class by using the specified encoding.\n     * @param  {Encoding} encoding?- The character encoding to use.\n     */\n    function StreamWriter(encoding) {\n        this.bufferBlob = new Blob(['']);\n        this.bufferText = '';\n        this.init(encoding);\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    Object.defineProperty(StreamWriter.prototype, \"buffer\", {\n        /**\n         * Gets the content written to the StreamWriter as Blob.\n         * @returns Blob\n         */\n        get: function () {\n            this.flush();\n            return this.bufferBlob;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StreamWriter.prototype, \"encoding\", {\n        /**\n         * Gets the encoding.\n         * @returns Encoding\n         */\n        get: function () {\n            return this.enc;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    StreamWriter.prototype.init = function (encoding) {\n        if (encoding === null || encoding === undefined) {\n            this.enc = new Encoding(false);\n            this.enc.type = 'Utf8';\n        }\n        else {\n            this.enc = encoding;\n            this.setBomByte();\n        }\n    };\n    /**\n     * Private method to set Byte Order Mark(BOM) value based on EncodingType\n     */\n    StreamWriter.prototype.setBomByte = function () {\n        if (this.encoding.includeBom) {\n            switch (this.encoding.type) {\n                case 'Unicode':\n                    var arrayUnicode = new ArrayBuffer(2);\n                    var uint8 = new Uint8Array(arrayUnicode);\n                    uint8[0] = 255;\n                    uint8[1] = 254;\n                    this.bufferBlob = new Blob([arrayUnicode]);\n                    break;\n                case 'Utf8':\n                    var arrayUtf8 = new ArrayBuffer(3);\n                    var utf8 = new Uint8Array(arrayUtf8);\n                    utf8[0] = 239;\n                    utf8[1] = 187;\n                    utf8[2] = 191;\n                    this.bufferBlob = new Blob([arrayUtf8]);\n                    break;\n                default:\n                    this.bufferBlob = new Blob(['']);\n                    break;\n            }\n        }\n    };\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param  {string} fileName - The file name to save\n     * @returns {void}\n     */\n    StreamWriter.prototype.save = function (fileName) {\n        if (this.bufferText !== '') {\n            this.flush();\n        }\n        Save.save(fileName, this.buffer);\n    };\n    /**\n     * Writes the specified string.\n     * @param  {string} value - The string to write. If value is null or undefined, nothing is written.\n     * @returns {void}\n     */\n    StreamWriter.prototype.write = function (value) {\n        if (this.encoding === undefined) {\n            throw new Error('Object Disposed Exception: current writer is disposed');\n        }\n        validateNullOrUndefined(value, 'string');\n        this.bufferText += value;\n        if (this.bufferText.length >= 10240) {\n            this.flush();\n        }\n    };\n    StreamWriter.prototype.flush = function () {\n        if (this.bufferText === undefined || this.bufferText === null || this.bufferText.length === 0) {\n            return;\n        }\n        var bufferArray = this.encoding.getBytes(this.bufferText, 0, this.bufferText.length);\n        this.bufferText = '';\n        this.bufferBlob = new Blob([this.bufferBlob, bufferArray]);\n    };\n    /**\n     * Writes the specified string followed by a line terminator\n     * @param  {string} value - The string to write. If value is null or undefined, nothing is written\n     * @returns {void}\n     */\n    StreamWriter.prototype.writeLine = function (value) {\n        if (this.encoding === undefined) {\n            throw new Error('Object Disposed Exception: current writer is disposed');\n        }\n        validateNullOrUndefined(value, 'string');\n        this.bufferText = this.bufferText + value + '\\r\\n';\n        if (this.bufferText.length >= 10240) {\n            this.flush();\n        }\n    };\n    /**\n     * Releases the resources used by the StreamWriter\n     * @returns {void}\n     */\n    StreamWriter.prototype.destroy = function () {\n        this.bufferBlob = undefined;\n        this.bufferText = undefined;\n        if (this.enc instanceof Encoding) {\n            this.enc.destroy();\n        }\n        this.enc = undefined;\n    };\n    return StreamWriter;\n}());\nexport { StreamWriter };\n", "/* eslint-disable */\nimport { Encoding } from '@syncfusion/ej2-file-utils';\n/**\n * array literal codes\n */\nvar ARR_LITERAL_CODES = new Int16Array(286);\nvar ARR_LITERAL_LENGTHS = new Uint8Array(286);\nvar ARR_DISTANCE_CODES = new Int16Array(30);\nvar ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\nvar CompressedStreamWriter = /** @class */ (function () {\n    /**\n     * Initializes compressor and writes ZLib header if needed.\n     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n     */\n    function CompressedStreamWriter(noWrap) {\n        this.pendingBuffer = new Uint8Array(1 << 16);\n        this.pendingBufLength = 0;\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.currentHash = 0;\n        this.matchStart = 0;\n        this.matchLength = 0;\n        this.matchPrevAvail = false;\n        this.blockStart = 0;\n        this.stringStart = 0;\n        this.lookAhead = 0;\n        this.totalBytesIn = 0;\n        this.inputOffset = 0;\n        this.inputEnd = 0;\n        this.windowSize = 1 << 15;\n        this.windowMask = this.windowSize - 1;\n        this.hashSize = 1 << 15;\n        this.hashMask = this.hashSize - 1;\n        this.hashShift = Math.floor((15 + 3 - 1) / 3);\n        this.maxDist = this.windowSize - 262;\n        this.checkSum = 1;\n        this.noWrap = false;\n        if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n            CompressedStreamWriter.initHuffmanTree();\n            CompressedStreamWriter.isHuffmanTreeInitiated = true;\n        }\n        this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n        this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n        this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n        this.arrDistances = new Uint16Array((1 << 14));\n        this.arrLiterals = new Uint8Array((1 << 14));\n        this.stream = [];\n        this.dataWindow = new Uint8Array(2 * this.windowSize);\n        this.hashHead = new Int16Array(this.hashSize);\n        this.hashPrevious = new Int16Array(this.windowSize);\n        this.blockStart = this.stringStart = 1;\n        this.noWrap = noWrap;\n        if (!noWrap) {\n            this.writeZLibHeader();\n        }\n    }\n    Object.defineProperty(CompressedStreamWriter.prototype, \"compressedData\", {\n        /**\n         * get compressed data\n         */\n        get: function () {\n            return this.stream;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressedStreamWriter.prototype, \"getCompressedString\", {\n        get: function () {\n            var compressedString = '';\n            if (this.stream !== undefined) {\n                for (var i = 0; i < this.stream.length; i++) {\n                    compressedString += String.fromCharCode.apply(null, this.stream[i]);\n                }\n            }\n            return compressedString;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Compresses data and writes it to the stream.\n     * @param {Uint8Array} data - data to compress\n     * @param {number} offset - offset in data\n     * @param {number} length - length of the data\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.write = function (data, offset, length) {\n        if (data === undefined || data === null) {\n            throw new Error('ArgumentException: data cannot null or undefined');\n        }\n        var end = offset + length;\n        if (0 > offset || offset > end || end > data.length) {\n            throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n        }\n        if (typeof data === 'string') {\n            var encode = new Encoding(false);\n            encode.type = 'Utf8';\n            data = new Uint8Array(encode.getBytes(data, 0, data.length));\n            end = offset + data.length;\n        }\n        this.inputBuffer = data;\n        this.inputOffset = offset;\n        this.inputEnd = end;\n        if (!this.noWrap) {\n            this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n        }\n        while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n            this.pendingBufferFlush();\n            this.compressData(false);\n        }\n    };\n    /**\n     * write ZLib header to the compressed data\n     * @return {void}\n     */\n    CompressedStreamWriter.prototype.writeZLibHeader = function () {\n        /* Initialize header.*/\n        var headerDate = (8 + (7 << 4)) << 8;\n        /* Save compression level.*/\n        headerDate |= ((5 >> 2) & 3) << 6;\n        /* Align header.*/\n        headerDate += 31 - (headerDate % 31);\n        /* Write header to stream.*/\n        this.pendingBufferWriteShortBytes(headerDate);\n    };\n    /**\n     *  Write Most Significant Bytes in to stream\n     * @param {number} s - check sum value\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteShortBytes = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n        this.pendingBuffer[this.pendingBufLength++] = s;\n    };\n    CompressedStreamWriter.prototype.compressData = function (finish) {\n        var success;\n        do {\n            this.fillWindow();\n            var canFlush = (finish && this.inputEnd === this.inputOffset);\n            success = this.compressSlow(canFlush, finish);\n        } while (this.pendingBufLength === 0 && success);\n        return success;\n    };\n    CompressedStreamWriter.prototype.compressSlow = function (flush, finish) {\n        if (this.lookAhead < 262 && !flush) {\n            return false;\n        }\n        while (this.lookAhead >= 262 || flush) {\n            if (this.lookAhead === 0) {\n                return this.lookAheadCompleted(finish);\n            }\n            if (this.stringStart >= 2 * this.windowSize - 262) {\n                this.slideWindow();\n            }\n            var prevMatch = this.matchStart;\n            var prevLen = this.matchLength;\n            if (this.lookAhead >= 3) {\n                this.discardMatch();\n            }\n            if (prevLen >= 3 && this.matchLength <= prevLen) {\n                prevLen = this.matchPreviousBest(prevMatch, prevLen);\n            }\n            else {\n                this.matchPreviousAvailable();\n            }\n            if (this.bufferPosition >= (1 << 14)) {\n                return this.huffmanIsFull(finish);\n            }\n        }\n        return true;\n    };\n    CompressedStreamWriter.prototype.discardMatch = function () {\n        var hashHead = this.insertString();\n        if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n            if (this.matchLength <= 5 && (this.matchLength === 3 && this.stringStart - this.matchStart > 4096)) {\n                this.matchLength = 3 - 1;\n            }\n        }\n    };\n    CompressedStreamWriter.prototype.matchPreviousAvailable = function () {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = true;\n        this.stringStart++;\n        this.lookAhead--;\n    };\n    CompressedStreamWriter.prototype.matchPreviousBest = function (prevMatch, prevLen) {\n        this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n        prevLen -= 2;\n        do {\n            this.stringStart++;\n            this.lookAhead--;\n            if (this.lookAhead >= 3) {\n                this.insertString();\n            }\n        } while (--prevLen > 0);\n        this.stringStart++;\n        this.lookAhead--;\n        this.matchPrevAvail = false;\n        this.matchLength = 3 - 1;\n        return prevLen;\n    };\n    CompressedStreamWriter.prototype.lookAheadCompleted = function (finish) {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = false;\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n        this.blockStart = this.stringStart;\n        return false;\n    };\n    CompressedStreamWriter.prototype.huffmanIsFull = function (finish) {\n        var len = this.stringStart - this.blockStart;\n        if (this.matchPrevAvail) {\n            len--;\n        }\n        var lastBlock = (finish && this.lookAhead === 0 && !this.matchPrevAvail);\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n        this.blockStart += len;\n        return !lastBlock;\n    };\n    CompressedStreamWriter.prototype.fillWindow = function () {\n        if (this.stringStart >= this.windowSize + this.maxDist) {\n            this.slideWindow();\n        }\n        while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n            var more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n            if (more > this.inputEnd - this.inputOffset) {\n                more = this.inputEnd - this.inputOffset;\n            }\n            this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n            this.inputOffset += more;\n            this.totalBytesIn += more;\n            this.lookAhead += more;\n        }\n        if (this.lookAhead >= 3) {\n            this.updateHash();\n        }\n    };\n    CompressedStreamWriter.prototype.slideWindow = function () {\n        this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n        this.matchStart -= this.windowSize;\n        this.stringStart -= this.windowSize;\n        this.blockStart -= this.windowSize;\n        for (var i = 0; i < this.hashSize; ++i) {\n            var m = this.hashHead[i] & 0xffff;\n            this.hashHead[i] = (((m >= this.windowSize) ? (m - this.windowSize) : 0));\n        }\n        for (var i = 0; i < this.windowSize; i++) {\n            var m = this.hashPrevious[i] & 0xffff;\n            this.hashPrevious[i] = ((m >= this.windowSize) ? (m - this.windowSize) : 0);\n        }\n    };\n    CompressedStreamWriter.prototype.insertString = function () {\n        var match;\n        var hash = ((this.currentHash << this.hashShift) ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n        this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n        this.hashHead[hash] = this.stringStart;\n        this.currentHash = hash;\n        return match & 0xffff;\n    };\n    CompressedStreamWriter.prototype.findLongestMatch = function (curMatch) {\n        var chainLen = 4096;\n        var niceLen = 258;\n        var scan = this.stringStart;\n        var match;\n        var bestEnd = this.stringStart + this.matchLength;\n        var bestLength = Math.max(this.matchLength, 3 - 1);\n        var limit = Math.max(this.stringStart - this.maxDist, 0);\n        var stringEnd = this.stringStart + 258 - 1;\n        var scanEnd1 = this.dataWindow[bestEnd - 1];\n        var scanEnd = this.dataWindow[bestEnd];\n        var data = this.dataWindow;\n        if (bestLength >= 32) {\n            chainLen >>= 2;\n        }\n        if (niceLen > this.lookAhead) {\n            niceLen = this.lookAhead;\n        }\n        do {\n            if (data[curMatch + bestLength] !== scanEnd ||\n                data[curMatch + bestLength - 1] !== scanEnd1 ||\n                data[curMatch] !== data[scan] ||\n                data[curMatch + 1] !== data[scan + 1]) {\n                continue;\n            }\n            match = curMatch + 2;\n            scan += 2;\n            /* tslint:disable */\n            while (data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n                /* tslint:disable */\n            }\n            if (scan > bestEnd) {\n                this.matchStart = curMatch;\n                bestEnd = scan;\n                bestLength = scan - this.stringStart;\n                if (bestLength >= niceLen) {\n                    break;\n                }\n                scanEnd1 = data[bestEnd - 1];\n                scanEnd = data[bestEnd];\n            }\n            scan = this.stringStart;\n        } while ((curMatch = (this.hashPrevious[curMatch & this.windowMask] & 0xffff)) > limit && --chainLen !== 0);\n        this.matchLength = Math.min(bestLength, this.lookAhead);\n        return this.matchLength >= 3;\n    };\n    CompressedStreamWriter.prototype.updateHash = function () {\n        this.currentHash = (this.dataWindow[this.stringStart] << this.hashShift) ^ this.dataWindow[this.stringStart + 1];\n    };\n    CompressedStreamWriter.prototype.huffmanTallyLit = function (literal) {\n        this.arrDistances[this.bufferPosition] = 0;\n        this.arrLiterals[this.bufferPosition++] = literal;\n        this.treeLiteral.codeFrequencies[literal]++;\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanTallyDist = function (dist, len) {\n        this.arrDistances[this.bufferPosition] = dist;\n        this.arrLiterals[this.bufferPosition++] = (len - 3);\n        var lc = this.huffmanLengthCode(len - 3);\n        this.treeLiteral.codeFrequencies[lc]++;\n        if (lc >= 265 && lc < 285) {\n            this.extraBits += Math.floor((lc - 261) / 4);\n        }\n        var dc = this.huffmanDistanceCode(dist - 1);\n        this.treeDistances.codeFrequencies[dc]++;\n        if (dc >= 4) {\n            this.extraBits += Math.floor((dc / 2 - 1));\n        }\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanFlushBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.treeLiteral.codeFrequencies[256]++;\n        this.treeLiteral.buildTree();\n        this.treeDistances.buildTree();\n        this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n        this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n        this.treeCodeLengths.buildTree();\n        var blTreeCodes = 4;\n        for (var i = 18; i > blTreeCodes; i--) {\n            if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n                blTreeCodes = i + 1;\n            }\n        }\n        var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() +\n            this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n        var static_len = this.extraBits;\n        for (var i = 0; i < 286; i++) {\n            static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];\n        }\n        for (var i = 0; i < 30; i++) {\n            static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];\n        }\n        if (opt_len >= static_len) {\n            // Force static trees.\n            opt_len = static_len;\n        }\n        if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n            this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n        }\n        else if (opt_len == static_len) {\n            // Encode with static tree.\n            this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n            this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n            this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n        else {\n            this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n            this.huffmanSendAllTrees(blTreeCodes);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n    };\n    CompressedStreamWriter.prototype.huffmanFlushStoredBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n        this.pendingBufferAlignToByte();\n        this.pendingBufferWriteShort(storedLength);\n        this.pendingBufferWriteShort(~storedLength);\n        this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n        this.huffmanReset();\n    };\n    CompressedStreamWriter.prototype.huffmanLengthCode = function (len) {\n        if (len === 255) {\n            return 285;\n        }\n        var code = 257;\n        while (len >= 8) {\n            code += 4;\n            len >>= 1;\n        }\n        return code + len;\n    };\n    CompressedStreamWriter.prototype.huffmanDistanceCode = function (distance) {\n        var code = 0;\n        while (distance >= 4) {\n            code += 2;\n            distance >>= 1;\n        }\n        return code + distance;\n    };\n    CompressedStreamWriter.prototype.huffmanSendAllTrees = function (blTreeCodes) {\n        this.treeCodeLengths.buildCodes();\n        this.treeLiteral.buildCodes();\n        this.treeDistances.buildCodes();\n        this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n        this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n        this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n        for (var rank = 0; rank < blTreeCodes; rank++) {\n            this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n        }\n        this.treeLiteral.writeTree(this.treeCodeLengths);\n        this.treeDistances.writeTree(this.treeCodeLengths);\n    };\n    CompressedStreamWriter.prototype.huffmanReset = function () {\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.treeLiteral.reset();\n        this.treeDistances.reset();\n        this.treeCodeLengths.reset();\n    };\n    CompressedStreamWriter.prototype.huffmanCompressBlock = function () {\n        for (var i = 0; i < this.bufferPosition; i++) {\n            var literalLen = this.arrLiterals[i] & 255;\n            var dist = this.arrDistances[i];\n            if (dist-- !== 0) {\n                var lc = this.huffmanLengthCode(literalLen);\n                this.treeLiteral.writeCodeToStream(lc);\n                var bits = Math.floor((lc - 261) / 4);\n                if (bits > 0 && bits <= 5) {\n                    this.pendingBufferWriteBits(literalLen & ((1 << bits) - 1), bits);\n                }\n                var dc = this.huffmanDistanceCode(dist);\n                this.treeDistances.writeCodeToStream(dc);\n                bits = Math.floor(dc / 2 - 1);\n                if (bits > 0) {\n                    this.pendingBufferWriteBits(dist & ((1 << bits) - 1), bits);\n                }\n            }\n            else {\n                this.treeLiteral.writeCodeToStream(literalLen);\n            }\n        }\n        this.treeLiteral.writeCodeToStream(256);\n    };\n    /**\n     * write bits in to internal buffer\n     * @param {number} b - source of bits\n     * @param {number} count - count of bits to write\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteBits = function (b, count) {\n        var uint = new Uint32Array(1);\n        uint[0] = this.pendingBufCache | (b << this.pendingBufBitsInCache);\n        this.pendingBufCache = uint[0];\n        this.pendingBufBitsInCache += count;\n        this.pendingBufferFlushBits();\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlush = function (isClose) {\n        this.pendingBufferFlushBits();\n        if (this.pendingBufLength > 0) {\n            var array = new Uint8Array(this.pendingBufLength);\n            array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n            this.stream.push(array);\n        }\n        this.pendingBufLength = 0;\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlushBits = function () {\n        var result = 0;\n        while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < (1 << 16)) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n            this.pendingBufCache >>= 8;\n            this.pendingBufBitsInCache -= 8;\n            result++;\n        }\n        return result;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteByteBlock = function (data, offset, length) {\n        var array = data.subarray(offset, offset + length);\n        this.pendingBuffer.set(array, this.pendingBufLength);\n        this.pendingBufLength += length;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteShort = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s;\n        this.pendingBuffer[this.pendingBufLength++] = (s >> 8);\n    };\n    CompressedStreamWriter.prototype.pendingBufferAlignToByte = function () {\n        if (this.pendingBufBitsInCache > 0) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n        }\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n    };\n    /**\n     * Huffman Tree literal calculation\n     * @private\n     */\n    CompressedStreamWriter.initHuffmanTree = function () {\n        var i = 0;\n        while (i < 144) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x030 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        while (i < 256) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x190 - 144 + i) << 7);\n            ARR_LITERAL_LENGTHS[i++] = 9;\n        }\n        while (i < 280) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x000 - 256 + i) << 9);\n            ARR_LITERAL_LENGTHS[i++] = 7;\n        }\n        while (i < 286) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x0c0 - 280 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        for (i = 0; i < 30; i++) {\n            ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n            ARR_DISTANCE_LENGTHS[i] = 5;\n        }\n    };\n    /**\n     * close the stream and write all pending buffer in to stream\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.close = function () {\n        do {\n            this.pendingBufferFlush(true);\n            if (!this.compressData(true)) {\n                this.pendingBufferFlush(true);\n                this.pendingBufferAlignToByte();\n                if (!this.noWrap) {\n                    this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n                    this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n                }\n                this.pendingBufferFlush(true);\n            }\n        } while (!(this.inputEnd === this.inputOffset) ||\n            !(this.pendingBufLength === 0));\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.destroy = function () {\n        this.stream = [];\n        this.stream = undefined;\n        this.pendingBuffer = undefined;\n        this.treeLiteral = undefined;\n        this.treeDistances = undefined;\n        this.treeCodeLengths = undefined;\n        this.arrLiterals = undefined;\n        this.arrDistances = undefined;\n        this.hashHead = undefined;\n        this.hashPrevious = undefined;\n        this.dataWindow = undefined;\n        this.inputBuffer = undefined;\n        this.pendingBufLength = undefined;\n        this.pendingBufCache = undefined;\n        this.pendingBufBitsInCache = undefined;\n        this.bufferPosition = undefined;\n        this.extraBits = undefined;\n        this.currentHash = undefined;\n        this.matchStart = undefined;\n        this.matchLength = undefined;\n        this.matchPrevAvail = undefined;\n        this.blockStart = undefined;\n        this.stringStart = undefined;\n        this.lookAhead = undefined;\n        this.totalBytesIn = undefined;\n        this.inputOffset = undefined;\n        this.inputEnd = undefined;\n        this.windowSize = undefined;\n        this.windowMask = undefined;\n        this.hashSize = undefined;\n        this.hashMask = undefined;\n        this.hashShift = undefined;\n        this.maxDist = undefined;\n        this.checkSum = undefined;\n        this.noWrap = undefined;\n    };\n    CompressedStreamWriter.isHuffmanTreeInitiated = false;\n    return CompressedStreamWriter;\n}());\nexport { CompressedStreamWriter };\n/**\n * represent the Huffman Tree\n */\nvar CompressorHuffmanTree = /** @class */ (function () {\n    /**\n     * Create new Huffman Tree\n     * @param {CompressedStreamWriter} writer instance\n     * @param {number} elementCount - element count\n     * @param {number} minCodes - minimum count\n     * @param {number} maxLength - maximum count\n     */\n    function CompressorHuffmanTree(writer, elementCount, minCodes, maxLength) {\n        this.writer = writer;\n        this.codeMinCount = minCodes;\n        this.maxLength = maxLength;\n        this.codeFrequency = new Uint16Array(elementCount);\n        this.lengthCount = new Int32Array(maxLength);\n    }\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"treeLength\", {\n        get: function () {\n            return this.codeCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeLengths\", {\n        get: function () {\n            return this.codeLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeFrequencies\", {\n        get: function () {\n            return this.codeFrequency;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CompressorHuffmanTree.prototype.setStaticCodes = function (codes, lengths) {\n        var temp = new Int16Array(codes.length);\n        temp.set(codes, 0);\n        this.codes = temp;\n        var lengthTemp = new Uint8Array(lengths.length);\n        lengthTemp.set(lengths, 0);\n        this.codeLength = lengthTemp;\n    };\n    /**\n     * reset all code data in tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.reset = function () {\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            this.codeFrequency[i] = 0;\n        }\n        this.codes = undefined;\n        this.codeLength = undefined;\n    };\n    /**\n     * write code to the compressor output stream\n     * @param {number} code - code to be written\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeCodeToStream = function (code) {\n        this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n    };\n    /**\n     * calculate code from their frequencies\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildCodes = function () {\n        var nextCode = new Int32Array(this.maxLength);\n        this.codes = new Int16Array(this.codeCount);\n        var code = 0;\n        for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n            nextCode[bitsCount] = code;\n            code += this.lengthCount[bitsCount] << (15 - bitsCount);\n        }\n        for (var i = 0; i < this.codeCount; i++) {\n            var bits = this.codeLength[i];\n            if (bits > 0) {\n                this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n                nextCode[bits - 1] += 1 << (16 - bits);\n            }\n        }\n    };\n    CompressorHuffmanTree.bitReverse = function (value) {\n        return (CompressorHuffmanTree.reverseBits[value & 15] << 12\n            | CompressorHuffmanTree.reverseBits[(value >> 4) & 15] << 8\n            | CompressorHuffmanTree.reverseBits[(value >> 8) & 15] << 4\n            | CompressorHuffmanTree.reverseBits[value >> 12]);\n    };\n    /**\n     * calculate length of compressed data\n     * @returns {number}\n     */\n    CompressorHuffmanTree.prototype.getEncodedLength = function () {\n        var len = 0;\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            len += this.codeFrequency[i] * this.codeLength[i];\n        }\n        return len;\n    };\n    /**\n     * calculate code frequencies\n     * @param {CompressorHuffmanTree} blTree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.calculateBLFreq = function (blTree) {\n        var maxCount;\n        var minCount;\n        var count;\n        var curLen = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            count = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxCount = 138;\n                minCount = 3;\n            }\n            else {\n                maxCount = 6;\n                minCount = 3;\n                if (curLen !== nextLen) {\n                    blTree.codeFrequency[nextLen]++;\n                    count = 0;\n                }\n            }\n            curLen = nextLen;\n            i++;\n            while (i < this.codeCount && curLen === this.codeLength[i]) {\n                i++;\n                if (++count >= maxCount) {\n                    break;\n                }\n            }\n            if (count < minCount) {\n                blTree.codeFrequency[curLen] += count;\n            }\n            else if (curLen !== 0) {\n                blTree.codeFrequency[16]++;\n            }\n            else if (count <= 10) {\n                blTree.codeFrequency[17]++;\n            }\n            else {\n                blTree.codeFrequency[18]++;\n            }\n        }\n    };\n    /**\n     * @param {CompressorHuffmanTree} blTree - write tree to output stream\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeTree = function (blTree) {\n        var maxRepeatCount;\n        var minRepeatCount;\n        var currentRepeatCount;\n        var currentCodeLength = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            currentRepeatCount = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxRepeatCount = 138;\n                minRepeatCount = 3;\n            }\n            else {\n                maxRepeatCount = 6;\n                minRepeatCount = 3;\n                if (currentCodeLength !== nextLen) {\n                    blTree.writeCodeToStream(nextLen);\n                    currentRepeatCount = 0;\n                }\n            }\n            currentCodeLength = nextLen;\n            i++;\n            while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n                i++;\n                if (++currentRepeatCount >= maxRepeatCount) {\n                    break;\n                }\n            }\n            if (currentRepeatCount < minRepeatCount) {\n                while (currentRepeatCount-- > 0) {\n                    blTree.writeCodeToStream(currentCodeLength);\n                }\n            }\n            else if (currentCodeLength !== 0) {\n                blTree.writeCodeToStream(16);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n            }\n            else if (currentRepeatCount <= 10) {\n                blTree.writeCodeToStream(17);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n            }\n            else {\n                blTree.writeCodeToStream(18);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n            }\n        }\n    };\n    /**\n     * Build huffman tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildTree = function () {\n        var codesCount = this.codeFrequency.length;\n        var arrTree = new Int32Array(codesCount);\n        var treeLength = 0;\n        var maxCount = 0;\n        for (var n = 0; n < codesCount; n++) {\n            var freq = this.codeFrequency[n];\n            if (freq !== 0) {\n                var pos = treeLength++;\n                var pPos = 0;\n                while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n                    arrTree[pos] = arrTree[pPos];\n                    pos = pPos;\n                }\n                arrTree[pos] = n;\n                maxCount = n;\n            }\n        }\n        while (treeLength < 2) {\n            arrTree[treeLength++] =\n                (maxCount < 2) ? ++maxCount : 0;\n        }\n        this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n        var leafsCount = treeLength;\n        var nodesCount = leafsCount;\n        var child = new Int32Array(4 * treeLength - 2);\n        var values = new Int32Array(2 * treeLength - 1);\n        for (var i = 0; i < treeLength; i++) {\n            var node = arrTree[i];\n            var iIndex = 2 * i;\n            child[iIndex] = node;\n            child[iIndex + 1] = -1;\n            values[i] = (this.codeFrequency[node] << 8);\n            arrTree[i] = i;\n        }\n        this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n        this.buildLength(child);\n    };\n    CompressorHuffmanTree.prototype.constructHuffmanTree = function (arrTree, treeLength, values, nodesCount, child) {\n        do {\n            var first = arrTree[0];\n            var last = arrTree[--treeLength];\n            var lastVal = values[last];\n            var pPos = 0;\n            var path = 1;\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            }\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n            var second = arrTree[0];\n            last = nodesCount++;\n            child[2 * last] = first;\n            child[2 * last + 1] = second;\n            var minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n            values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n            pPos = 0;\n            path = 1;\n            /* tslint:disable */\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            } /* tslint:disable */\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n        } while (treeLength > 1);\n    };\n    CompressorHuffmanTree.prototype.buildLength = function (child) {\n        this.codeLength = new Uint8Array(this.codeFrequency.length);\n        var numNodes = Math.floor(child.length / 2);\n        var numLeafs = Math.floor((numNodes + 1) / 2);\n        var overflow = 0;\n        for (var i = 0; i < this.maxLength; i++) {\n            this.lengthCount[i] = 0;\n        }\n        overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n        if (overflow === 0) {\n            return;\n        }\n        var iIncreasableLength = this.maxLength - 1;\n        do {\n            while (this.lengthCount[--iIncreasableLength] === 0) {\n                /* tslint:disable */\n            }\n            do {\n                this.lengthCount[iIncreasableLength]--;\n                this.lengthCount[++iIncreasableLength]++;\n                overflow -= (1 << (this.maxLength - 1 - iIncreasableLength));\n            } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n        } while (overflow > 0);\n        this.recreateTree(child, overflow, numLeafs);\n    };\n    CompressorHuffmanTree.prototype.recreateTree = function (child, overflow, numLeafs) {\n        this.lengthCount[this.maxLength - 1] += overflow;\n        this.lengthCount[this.maxLength - 2] -= overflow;\n        var nodePtr = 2 * numLeafs;\n        for (var bits = this.maxLength; bits !== 0; bits--) {\n            var n = this.lengthCount[bits - 1];\n            while (n > 0) {\n                var childPtr = 2 * child[nodePtr++];\n                if (child[childPtr + 1] === -1) {\n                    this.codeLength[child[childPtr]] = bits;\n                    n--;\n                }\n            }\n        }\n    };\n    CompressorHuffmanTree.prototype.calculateOptimalCodeLength = function (child, overflow, numNodes) {\n        var lengths = new Int32Array(numNodes);\n        lengths[numNodes - 1] = 0;\n        for (var i = numNodes - 1; i >= 0; i--) {\n            var childIndex = 2 * i + 1;\n            if (child[childIndex] !== -1) {\n                var bitLength = lengths[i] + 1;\n                if (bitLength > this.maxLength) {\n                    bitLength = this.maxLength;\n                    overflow++;\n                }\n                lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n            }\n            else {\n                var bitLength = lengths[i];\n                this.lengthCount[bitLength - 1]++;\n                this.codeLength[child[childIndex - 1]] = lengths[i];\n            }\n        }\n        return overflow;\n    };\n    CompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n    CompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    return CompressorHuffmanTree;\n}());\nexport { CompressorHuffmanTree };\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\nvar ChecksumCalculator = /** @class */ (function () {\n    function ChecksumCalculator() {\n    }\n    /**\n     * Updates checksum by calculating checksum of the\n     * given buffer and adding it to current value.\n     * @param {number} checksum - current checksum.\n     * @param {Uint8Array} buffer - data byte array.\n     * @param {number} offset - offset in the buffer.\n     * @param {number} length - length of data to be used from the stream.\n     * @returns {number}\n     */\n    ChecksumCalculator.checksumUpdate = function (checksum, buffer, offset, length) {\n        var uint = new Uint32Array(1);\n        uint[0] = checksum;\n        var checksum_uint = uint[0];\n        var s1 = uint[0] = checksum_uint & 65535;\n        var s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n        while (length > 0) {\n            var steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n            length -= steps;\n            while (--steps >= 0) {\n                s1 = s1 + (uint[0] = (buffer[offset++] & 255));\n                s2 = s2 + s1;\n            }\n            s1 %= ChecksumCalculator.checksumBase;\n            s2 %= ChecksumCalculator.checksumBase;\n        }\n        checksum_uint = (s2 << ChecksumCalculator.checkSumBitOffset) | s1;\n        return checksum_uint;\n    };\n    ChecksumCalculator.checkSumBitOffset = 16;\n    ChecksumCalculator.checksumBase = 65521;\n    ChecksumCalculator.checksumIterationCount = 3800;\n    return ChecksumCalculator;\n}());\nexport { ChecksumCalculator };\n/* eslint-enable */ \n", "/* eslint-disable */\nvar Utils = /** @class */ (function () {\n    function Utils() {\n    }\n    Utils.bitReverse = function (value) {\n        return (Utils.reverseBits[value & 15] << 12\n            | Utils.reverseBits[(value >> 4) & 15] << 8\n            | Utils.reverseBits[(value >> 8) & 15] << 4\n            | Utils.reverseBits[value >> 12]);\n    };\n    Utils.bitConverterToInt32 = function (value, index) {\n        return value[index] | value[index + 1] << 8 | value[index + 2] << 16 | value[index + 3] << 24;\n    };\n    Utils.bitConverterToInt16 = function (value, index) {\n        return value[index] | value[index + 1] << 8;\n    };\n    Utils.bitConverterToUInt32 = function (value) {\n        var uint = new Uint32Array(1);\n        uint[0] = value;\n        return uint[0];\n    };\n    Utils.bitConverterToUInt16 = function (value, index) {\n        var uint = new Uint16Array(1);\n        uint[0] = (value[index] | value[index + 1] << 8);\n        return uint[0];\n    };\n    Utils.bitConverterUintToInt32 = function (value) {\n        var uint = new Int32Array(1);\n        uint[0] = value;\n        return uint[0];\n    };\n    Utils.bitConverterInt32ToUint = function (value) {\n        var uint = new Uint32Array(1);\n        uint[0] = value;\n        return uint[0];\n    };\n    Utils.bitConverterInt32ToInt16 = function (value) {\n        var uint = new Int16Array(1);\n        uint[0] = value;\n        return uint[0];\n    };\n    Utils.byteToString = function (value) {\n        var str = '';\n        for (var i = 0; i < value.length; i++) {\n            str += String.fromCharCode(value[i]);\n        }\n        return str;\n    };\n    Utils.byteIntToString = function (value) {\n        var str = '';\n        for (var i = 0; i < value.length; i++) {\n            str += String.fromCharCode(value[i]);\n        }\n        return str;\n    };\n    Utils.arrayCopy = function (source, sourceIndex, destination, destinationIndex, dataToCopy) {\n        var temp = new Uint8Array(source.buffer, sourceIndex);\n        var data = temp.subarray(0, dataToCopy);\n        destination.set(data, destinationIndex);\n    };\n    Utils.mergeArray = function (arrayOne, arrayTwo) {\n        var mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);\n        mergedArray.set(arrayOne);\n        mergedArray.set(arrayTwo, arrayOne.length);\n        return mergedArray;\n    };\n    /**\n     * @private\n     */\n    Utils.encodedString = function (input) {\n        var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        var chr1;\n        var chr2;\n        var chr3;\n        var encode1;\n        var encode2;\n        var encode3;\n        var encode4;\n        var count = 0;\n        var resultIndex = 0;\n        /*let dataUrlPrefix: string = 'data:';*/\n        input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n        var totalLength = input.length * 3 / 4;\n        if (input.charAt(input.length - 1) === keyStr.charAt(64)) {\n            totalLength--;\n        }\n        if (input.charAt(input.length - 2) === keyStr.charAt(64)) {\n            totalLength--;\n        }\n        if (totalLength % 1 !== 0) {\n            // totalLength is not an integer, the length does not match a valid\n            // base64 content. That can happen if:\n            // - the input is not a base64 content\n            // - the input is *almost* a base64 content, with a extra chars at the\n            // beginning or at the end\n            // - the input uses a base64 variant (base64url for example)\n            throw new Error('Invalid base64 input, bad content length.');\n        }\n        var output = new Uint8Array(totalLength | 0);\n        while (count < input.length) {\n            encode1 = keyStr.indexOf(input.charAt(count++));\n            encode2 = keyStr.indexOf(input.charAt(count++));\n            encode3 = keyStr.indexOf(input.charAt(count++));\n            encode4 = keyStr.indexOf(input.charAt(count++));\n            chr1 = (encode1 << 2) | (encode2 >> 4);\n            chr2 = ((encode2 & 15) << 4) | (encode3 >> 2);\n            chr3 = ((encode3 & 3) << 6) | encode4;\n            output[resultIndex++] = chr1;\n            if (encode3 !== 64) {\n                output[resultIndex++] = chr2;\n            }\n            if (encode4 !== 64) {\n                output[resultIndex++] = chr3;\n            }\n        }\n        return output;\n    };\n    Utils.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n    Utils.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    return Utils;\n}());\nexport { Utils };\n/* eslint-enable */ \n", "/* eslint-disable */\nimport { Utils } from './index';\nvar DecompressorHuffmanTree = /** @class */ (function () {\n    function DecompressorHuffmanTree(lengths) {\n        this.buildTree(lengths);\n    }\n    DecompressorHuffmanTree.init = function () {\n        var lengths;\n        var index;\n        // Generate huffman tree for lengths.\n        lengths = new Uint8Array(288);\n        index = 0;\n        while (index < 144) {\n            lengths[index++] = 8;\n        }\n        while (index < 256) {\n            lengths[index++] = 9;\n        }\n        while (index < 280) {\n            lengths[index++] = 7;\n        }\n        while (index < 288) {\n            lengths[index++] = 8;\n        }\n        DecompressorHuffmanTree.m_LengthTree = new DecompressorHuffmanTree(lengths);\n        // Generate huffman tree for distances.\n        lengths = new Uint8Array(32);\n        index = 0;\n        while (index < 32) {\n            lengths[index++] = 5;\n        }\n        DecompressorHuffmanTree.m_DistanceTree = new DecompressorHuffmanTree(lengths);\n    };\n    /// <summary>\n    /// Prepares data for generating huffman tree.\n    /// </summary>\n    /// <param name=\"blCount\">Array of counts of each code length.</param>\n    /// <param name=\"nextCode\">Numerical values of the smallest code for each code length.</param>\n    /// <param name=\"lengths\">Array of code lengths.</param>\n    /// <param name=\"treeSize\">Calculated tree size.</param>\n    /// <returns>Code.</returns>\n    DecompressorHuffmanTree.prototype.prepareData = function (blCount, nextCode, lengths) {\n        var code = 0;\n        var treeSize = 512;\n        // Count number of codes for each code length.\n        for (var i = 0; i < lengths.length; i++) {\n            var length_1 = lengths[i];\n            if (length_1 > 0) {\n                blCount[length_1]++;\n            }\n        }\n        for (var bits = 1; bits <= DecompressorHuffmanTree.MAX_BITLEN; bits++) {\n            nextCode[bits] = code;\n            code += blCount[bits] << (16 - bits);\n            if (bits >= 10) {\n                var start = nextCode[bits] & 0x1ff80;\n                var end = code & 0x1ff80;\n                treeSize += (end - start) >> (16 - bits);\n            }\n        }\n        /*      if( code != 65536 )\n          throw new ZipException( \"Code lengths don't add up properly.\" );*/\n        return { 'code': code, 'treeSize': treeSize };\n    };\n    /// <summary>\n    /// Generates huffman tree.\n    /// </summary>\n    /// <param name=\"blCount\">Array of counts of each code length.</param>\n    /// <param name=\"nextCode\">Numerical values of the smallest code for each code length.</param>\n    /// <param name=\"code\">Precalculated code.</param>\n    /// <param name=\"lengths\">Array of code lengths.</param>\n    /// <param name=\"treeSize\">Calculated size of the tree.</param>\n    /// <returns>Generated tree.</returns>\n    DecompressorHuffmanTree.prototype.treeFromData = function (blCount, nextCode, lengths, code, treeSize) {\n        var tree = new Int16Array(treeSize);\n        var pointer = 512;\n        var increment = 1 << 7;\n        for (var bits = DecompressorHuffmanTree.MAX_BITLEN; bits >= 10; bits--) {\n            var end = code & 0x1ff80;\n            code -= blCount[bits] << (16 - bits);\n            var start = code & 0x1ff80;\n            for (var i = start; i < end; i += increment) {\n                tree[Utils.bitReverse(i)] = Utils.bitConverterInt32ToInt16((-pointer << 4) | bits);\n                pointer += 1 << (bits - 9);\n            }\n        }\n        for (var i = 0; i < lengths.length; i++) {\n            var bits = lengths[i];\n            if (bits == 0) {\n                continue;\n            }\n            code = nextCode[bits];\n            var revcode = Utils.bitReverse(code);\n            if (bits <= 9) {\n                do {\n                    tree[revcode] = Utils.bitConverterInt32ToInt16((i << 4) | bits);\n                    revcode += 1 << bits;\n                } while (revcode < 512);\n            }\n            else {\n                var subTree = tree[revcode & 511];\n                var treeLen = 1 << (subTree & 15);\n                subTree = -(subTree >> 4);\n                do {\n                    tree[subTree | (revcode >> 9)] = Utils.bitConverterInt32ToInt16((i << 4) | bits);\n                    revcode += 1 << bits;\n                } while (revcode < treeLen);\n            }\n            nextCode[bits] = code + (1 << (16 - bits));\n        }\n        return tree;\n    };\n    /// <summary>\n    /// Builds huffman tree from array of code lengths.\n    /// </summary>\n    /// <param name=\"lengths\">Array of code lengths.</param>\n    DecompressorHuffmanTree.prototype.buildTree = function (lengths) {\n        // Count of codes for each code length.\n        var blCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        // Numerical value of the smallest code for each code length.\n        var nextCode = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        var prepareData = this.prepareData(blCount, nextCode, lengths);\n        this.m_Tree = this.treeFromData(blCount, nextCode, lengths, prepareData.code, prepareData.treeSize);\n    };\n    /// <summary>\n    /// Reads and decompresses one symbol.\n    /// </summary>\n    /// <param name=\"input\"></param>\n    /// <returns></returns>\n    DecompressorHuffmanTree.prototype.unpackSymbol = function (input) {\n        var lookahead;\n        var symbol;\n        if ((lookahead = input.peekBits(9)) >= 0) {\n            if ((symbol = this.m_Tree[lookahead]) >= 0) {\n                input.skipBits((symbol & 15));\n                return symbol >> 4;\n            }\n            var subtree = -(symbol >> 4);\n            var bitlen = symbol & 15;\n            if ((lookahead = input.peekBits(bitlen)) >= 0) {\n                symbol = this.m_Tree[subtree | (lookahead >> 9)];\n                input.skipBits((symbol & 15));\n                return symbol >> 4;\n            }\n            else {\n                var bits = input.availableBits;\n                lookahead = input.peekBits(bits);\n                symbol = this.m_Tree[subtree | (lookahead >> 9)];\n                if ((symbol & 15) <= bits) {\n                    input.skipBits((symbol & 15));\n                    return symbol >> 4;\n                }\n                else {\n                    return -1;\n                }\n            }\n        }\n        else {\n            var bits = input.availableBits;\n            lookahead = input.peekBits(bits);\n            symbol = this.m_Tree[lookahead];\n            if (symbol >= 0 && (symbol & 15) <= bits) {\n                input.skipBits((symbol & 15));\n                return symbol >> 4;\n            }\n            else {\n                return -1;\n            }\n        }\n    };\n    Object.defineProperty(DecompressorHuffmanTree, \"lengthTree\", {\n        /// <summary>\n        /// GET huffman tree for encoding and decoding lengths.\n        /// </summary>\n        get: function () {\n            return this.m_LengthTree;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DecompressorHuffmanTree, \"distanceTree\", {\n        /// <summary>\n        /// GET huffman tree for encoding and decoding distances.\n        /// </summary>\n        get: function () {\n            return this.m_DistanceTree;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /// <summary>\n    /// Maximum count of bits.\n    /// </summary>\n    DecompressorHuffmanTree.MAX_BITLEN = 15;\n    return DecompressorHuffmanTree;\n}());\nexport { DecompressorHuffmanTree };\n/* eslint-enable */ \n", "/* eslint-disable */\n/// <summary>\n/// Checksum calculator, based on Adler32 algorithm.\n/// </summary>\nvar ChecksumCalculator = /** @class */ (function () {\n    function ChecksumCalculator() {\n    }\n    /// <summary>\n    /// Updates checksum by calculating checksum of the\n    /// given buffer and adding it to current value.\n    /// </summary>\n    /// <param name=\"checksum\">Current checksum.</param>\n    /// <param name=\"buffer\">Data byte array.</param>\n    /// <param name=\"offset\">Offset in the buffer.</param>\n    /// <param name=\"length\">Length of data to be used from the stream.</param>\n    ChecksumCalculator.ChecksumUpdate = function (checksum, buffer, offset, length) {\n        var checkSumUInt = checksum;\n        var s1 = checkSumUInt & 65535;\n        var s2 = checkSumUInt >> this.DEF_CHECKSUM_BIT_OFFSET;\n        while (length > 0) {\n            var steps = Math.min(length, this.DEF_CHECKSUM_ITERATIONSCOUNT);\n            length -= steps;\n            while (--steps >= 0) {\n                s1 = s1 + (buffer[offset++] & 255);\n                s2 = s2 + s1;\n            }\n            s1 %= this.DEF_CHECKSUM_BASE;\n            s2 %= this.DEF_CHECKSUM_BASE;\n        }\n        checkSumUInt = (s2 << this.DEF_CHECKSUM_BIT_OFFSET) | s1;\n        checksum = checkSumUInt;\n    };\n    /// <summary>\n    /// Generates checksum by calculating checksum of the\n    /// given buffer.\n    /// </summary>\n    /// <param name=\"buffer\">Data byte array.</param>\n    /// <param name=\"offset\">Offset in the buffer.</param>\n    /// <param name=\"length\">Length of data to be used from the stream.</param>\n    ChecksumCalculator.ChecksumGenerate = function (buffer, offset, length) {\n        var result = 1;\n        ChecksumCalculator.ChecksumUpdate(result, buffer, offset, length);\n        return result;\n    };\n    /// <summary>\n    /// Bits offset, used in adler checksum calculation.\n    /// </summary>\n    ChecksumCalculator.DEF_CHECKSUM_BIT_OFFSET = 16;\n    /// <summary>\n    /// Lagrest prime, less than 65535\n    /// </summary>\n    ChecksumCalculator.DEF_CHECKSUM_BASE = 65521;\n    /// <summary>\n    /// Count of iteration used in calculated of the adler checksumm.\n    /// </summary>\n    ChecksumCalculator.DEF_CHECKSUM_ITERATIONSCOUNT = 3800;\n    return ChecksumCalculator;\n}());\nexport { ChecksumCalculator };\n/* eslint-enable */ \n", "/* eslint-disable */\nimport { DecompressorHuffmanTree } from './decompressor-huffman-tree';\nimport { Utils } from './utils';\nimport { ChecksumCalculator } from './checksum-calculator';\nvar CompressedStreamReader = /** @class */ (function () {\n    function CompressedStreamReader(stream, bNoWrap) {\n        /// <summary>\n        /// Code lengths for the code length alphabet.\n        /// </summary>\n        this.defaultHuffmanDynamicTree = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n        /// <summary>\n        /// Mask for compression method to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_METHOD_MASK = 15 << 8;\n        /// <summary>\n        /// Mask for compression info to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_INFO_MASK = 240 << 8;\n        /// <summary>\n        /// Mask for check bits to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_FLAGS_FCHECK = 31;\n        /// <summary>\n        /// Mask for dictionary presence to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_FLAGS_FDICT = 32;\n        /// <summary>\n        /// Mask for compression level to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_FLAGS_FLEVEL = 192;\n        /// <summary>\n        /// Maximum size of the data window.\n        /// </summary>\n        this.DEF_MAX_WINDOW_SIZE = 65535;\n        /// <summary>\n        /// Maximum length of the repeatable block.\n        /// </summary>\n        this.DEF_HUFFMAN_REPEATE_MAX = 258;\n        /// <summary>\n        /// End of the block sign.\n        /// </summary>\n        this.DEF_HUFFMAN_END_BLOCK = 256;\n        /// <summary>\n        /// Minimal length code.\n        /// </summary>\n        this.DEF_HUFFMAN_LENGTH_MINIMUMCODE = 257;\n        /// <summary>\n        /// Maximal length code.\n        /// </summary>\n        this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE = 285;\n        /// <summary>\n        /// Maximal distance code.\n        /// </summary>\n        this.DEF_HUFFMAN_DISTANCE_MAXIMUMCODE = 29;\n        /// <summary>\n        /// Currently calculated checksum,\n        /// based on Adler32 algorithm.\n        /// </summary>\n        this.mCheckSum = 1;\n        /// <summary>\n        /// Currently read 4 bytes.\n        /// </summary>\n        this.tBuffer = 0;\n        /// <summary>\n        /// Count of bits that are in buffer.\n        /// </summary>\n        this.mBufferedBits = 0;\n        /// <summary>\n        /// Temporary buffer.\n        /// </summary>\n        this.mTempBuffer = new Uint8Array(4);\n        /// <summary>\n        /// 32k buffer for unpacked data.\n        /// </summary>\n        this.mBlockBuffer = new Uint8Array(this.DEF_MAX_WINDOW_SIZE);\n        /// <summary>\n        /// No wrap mode.\n        /// </summary>\n        this.mbNoWrap = false;\n        /// <summary>\n        /// Window size, can not be larger than 32k.\n        /// </summary>\n        this.mWindowSize = 0;\n        /// <summary>\n        /// Current position in output stream.\n        /// Current in-block position can be extracted by applying Int16.MaxValue mask.\n        /// </summary>\n        this.mCurrentPosition = 0;\n        /// <summary>\n        /// Data length.\n        /// Current in-block position can be extracted by applying Int16.MaxValue mask.\n        /// </summary>\n        this.mDataLength = 0;\n        /// <summary>\n        /// Specifies wheather next block can to be read.\n        /// Reading can be denied because the header of the last block have been read.\n        /// </summary>\n        this.mbCanReadNextBlock = true;\n        /// <summary>\n        /// Specifies wheather user can read more data from stream.\n        /// </summary>\n        this.mbCanReadMoreData = true;\n        /// <summary>\n        /// Specifies wheather checksum has been read.\n        /// </summary>\n        this.mbCheckSumRead = false;\n        if (stream == null) {\n            throw new DOMException('stream');\n        }\n        if (stream.length === 0) {\n            throw new DOMException('stream - string can not be empty');\n        }\n        DecompressorHuffmanTree.init();\n        this.mInputStream = new Stream(stream);\n        this.mbNoWrap = bNoWrap;\n        if (!this.mbNoWrap) {\n            this.readZLibHeader();\n        }\n        this.decodeBlockHeader();\n    }\n    Object.defineProperty(CompressedStreamReader.prototype, \"mBuffer\", {\n        get: function () {\n            return this.tBuffer;\n        },\n        set: function (value) {\n            this.tBuffer = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initializes compressor and writes ZLib header if needed.\n     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n     */\n    /// <summary>\n    /// Reads specified count of bits without adjusting position.\n    /// </summary>\n    /// <param name=\"count\">Count of bits to be read.</param>\n    /// <returns>Read value.</returns>\n    CompressedStreamReader.prototype.peekBits = function (count) {\n        if (count < 0) {\n            throw new DOMException('count', 'Bits count can not be less than zero.');\n        }\n        if (count > 32) {\n            throw new DOMException('count', 'Count of bits is too large.');\n        }\n        // If buffered data is not enough to give result,\n        // fill buffer.\n        if (this.mBufferedBits < count) {\n            this.fillBuffer();\n        }\n        // If you want to read 4 bytes and there is partial data in\n        // buffer, than you will fail.\n        if (this.mBufferedBits < count) {\n            return -1;\n        }\n        // Create bitmask for reading of count bits\n        var bitMask = ~(4294967295 << count);\n        var result = Utils.bitConverterUintToInt32(this.mBuffer & bitMask);\n        //Debug.WriteLine( /*new string( ' ', 32 - mBufferedBits + (int)( ( 32 - mBufferedBits ) / 8 ) ) + BitsToString( (int)mBuffer, mBufferedBits ) + \" \" + BitsToString( result, count ) +*/ \" \" + result.ToString() );\n        return result;\n    };\n    CompressedStreamReader.prototype.fillBuffer = function () {\n        var length = 4 - (this.mBufferedBits >> 3) -\n            (((this.mBufferedBits & 7) !== 0) ? 1 : 0);\n        if (length === 0) {\n            return;\n        }\n        //TODO: fix this\n        var bytesRead = this.mInputStream.read(this.mTempBuffer, 0, length);\n        for (var i = 0; i < bytesRead; i++) {\n            this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer |\n                (Utils.bitConverterInt32ToUint(this.mTempBuffer[i] << this.mBufferedBits)));\n            this.mBufferedBits += 8;\n        }\n        //TODO: fix this\n    };\n    /// <summary>\n    /// Skips specified count of bits.\n    /// </summary>\n    /// <param name=\"count\">Count of bits to be skipped.</param>\n    CompressedStreamReader.prototype.skipBits = function (count) {\n        if (count < 0) {\n            throw new DOMException('count', 'Bits count can not be less than zero.');\n        }\n        if (count === 0) {\n            return;\n        }\n        if (count >= this.mBufferedBits) {\n            count -= this.mBufferedBits;\n            this.mBufferedBits = 0;\n            this.mBuffer = 0;\n            // if something left, skip it.\n            if (count > 0) {\n                // Skip entire bytes.\n                this.mInputStream.position += (count >> 3); //TODO: fix this\n                count &= 7;\n                // Skip bits.\n                if (count > 0) {\n                    this.fillBuffer();\n                    this.mBufferedBits -= count;\n                    this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n                }\n            }\n        }\n        else {\n            this.mBufferedBits -= count;\n            this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n        }\n    };\n    Object.defineProperty(CompressedStreamReader.prototype, \"availableBits\", {\n        get: function () {\n            return this.mBufferedBits;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /// <summary>\n    /// Reads ZLib header with compression method and flags.\n    /// </summary>\n    CompressedStreamReader.prototype.readZLibHeader = function () {\n        // first 8 bits - compression Method and flags\n        // 8 other - flags\n        var header = this.readInt16();\n        //Debug.WriteLine( BitsToString( header ) );\n        if (header === -1) {\n            throw new DOMException('Header of the stream can not be read.');\n        }\n        if (header % 31 !== 0) {\n            throw new DOMException('Header checksum illegal');\n        }\n        if ((header & this.DEF_HEADER_METHOD_MASK) !== (8 << 8)) {\n            throw new DOMException('Unsupported compression method.');\n        }\n        this.mWindowSize = Math.pow(2, ((header & this.DEF_HEADER_INFO_MASK) >> 12) + 8);\n        if (this.mWindowSize > 65535) {\n            throw new DOMException('Unsupported window size for deflate compression method.');\n        }\n        if ((header & this.DEF_HEADER_FLAGS_FDICT) >> 5 === 1) {\n            // Get dictionary.\n            throw new DOMException('Custom dictionary is not supported at the moment.');\n        }\n    };\n    /// <summary>\n    /// TODO: place correct comment here\n    /// </summary>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readInt16 = function () {\n        var result = (this.readBits(8) << 8);\n        result |= this.readBits(8);\n        return result;\n    };\n    /// <summary>\n    /// Reads specified count of bits from stream.\n    /// </summary>\n    /// <param name=\"count\">Count of bits to be read.</param>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readBits = function (count) {\n        var result = this.peekBits(count);\n        if (result === -1) {\n            return -1;\n        }\n        this.mBufferedBits -= count;\n        this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n        return result;\n    };\n    /// <summary>\n    /// Reads and decodes block of data.\n    /// </summary>\n    /// <returns>True if buffer was empty and new data was read, otherwise - False.</returns>\n    CompressedStreamReader.prototype.decodeBlockHeader = function () {\n        if (!this.mbCanReadNextBlock) {\n            return false;\n        }\n        var bFinalBlock = this.readBits(1);\n        if (bFinalBlock === -1) {\n            return false;\n        }\n        var blockType = this.readBits(2);\n        if (blockType === -1) {\n            return false;\n        }\n        this.mbCanReadNextBlock = (bFinalBlock === 0);\n        //      ChecksumReset();\n        switch (blockType) {\n            case 0:\n                // Uncompressed data\n                this.mbReadingUncompressed = true;\n                this.skipToBoundary();\n                var length_1 = this.readInt16Inverted();\n                var lengthComplement = this.readInt16Inverted();\n                if (length_1 !== (lengthComplement ^ 0xffff)) {\n                    throw new DOMException('Wrong block length.');\n                }\n                if (length_1 > 65535) {\n                    throw new DOMException('Uncompressed block length can not be more than 65535.');\n                }\n                this.mUncompressedDataLength = length_1;\n                this.mCurrentLengthTree = null;\n                this.mCurrentDistanceTree = null;\n                break;\n            case 1:\n                // Compressed data with fixed huffman codes.\n                this.mbReadingUncompressed = false;\n                this.mUncompressedDataLength = -1;\n                this.mCurrentLengthTree = DecompressorHuffmanTree.lengthTree;\n                this.mCurrentDistanceTree = DecompressorHuffmanTree.distanceTree;\n                break;\n            case 2:\n                // Compressed data with dynamic huffman codes.\n                this.mbReadingUncompressed = false;\n                this.mUncompressedDataLength = -1;\n                var trees = this.decodeDynamicHeader(this.mCurrentLengthTree, this.mCurrentDistanceTree);\n                this.mCurrentLengthTree = trees.lengthTree;\n                this.mCurrentDistanceTree = trees.distanceTree;\n                break;\n            default:\n                throw new DOMException('Wrong block type.');\n        }\n        return true;\n    };\n    /// <summary>\n    /// Discards left-most partially used byte.\n    /// </summary>\n    CompressedStreamReader.prototype.skipToBoundary = function () {\n        this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> (this.mBufferedBits & 7));\n        this.mBufferedBits &= ~7;\n    };\n    /// <summary>\n    /// TODO: place correct comment here\n    /// </summary>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readInt16Inverted = function () {\n        var result = (this.readBits(8));\n        result |= this.readBits(8) << 8;\n        return result;\n    };\n    /// <summary>\n    /// Reades dynamic huffman codes from block header.\n    /// </summary>\n    /// <param name=\"lengthTree\">Literals/Lengths tree.</param>\n    /// <param name=\"distanceTree\">Distances tree.</param>\n    CompressedStreamReader.prototype.decodeDynamicHeader = function (lengthTree, distanceTree) {\n        var bLastSymbol = 0;\n        var iLengthsCount = this.readBits(5);\n        var iDistancesCount = this.readBits(5);\n        var iCodeLengthsCount = this.readBits(4);\n        if (iLengthsCount < 0 || iDistancesCount < 0 || iCodeLengthsCount < 0) {\n            throw new DOMException('Wrong dynamic huffman codes.');\n        }\n        iLengthsCount += 257;\n        iDistancesCount += 1;\n        var iResultingCodeLengthsCount = iLengthsCount + iDistancesCount;\n        var arrResultingCodeLengths = new Uint8Array(iResultingCodeLengthsCount);\n        var arrDecoderCodeLengths = new Uint8Array(19);\n        iCodeLengthsCount += 4;\n        var iCurrentCode = 0;\n        while (iCurrentCode < iCodeLengthsCount) {\n            var len = this.readBits(3);\n            if (len < 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            arrDecoderCodeLengths[this.defaultHuffmanDynamicTree[iCurrentCode++]] = len;\n        }\n        var treeInternalDecoder = new DecompressorHuffmanTree(arrDecoderCodeLengths);\n        iCurrentCode = 0;\n        for (;;) {\n            var symbol = void 0;\n            var bNeedBreak = false;\n            symbol = treeInternalDecoder.unpackSymbol(this);\n            while ((symbol & ~15) === 0) {\n                arrResultingCodeLengths[iCurrentCode++] = bLastSymbol = symbol;\n                if (iCurrentCode === iResultingCodeLengthsCount) {\n                    bNeedBreak = true;\n                    break;\n                }\n                symbol = treeInternalDecoder.unpackSymbol(this);\n            }\n            if (bNeedBreak) {\n                break;\n            }\n            if (symbol < 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            if (symbol >= 17) {\n                bLastSymbol = 0;\n            }\n            else if (iCurrentCode === 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            var miRepSymbol = symbol - 16;\n            var bits = CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_BITS[miRepSymbol];\n            var count = this.readBits(bits);\n            if (count < 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            count += CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS[miRepSymbol];\n            if (iCurrentCode + count > iResultingCodeLengthsCount) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            while (count-- > 0) {\n                arrResultingCodeLengths[iCurrentCode++] = bLastSymbol;\n            }\n            if (iCurrentCode === iResultingCodeLengthsCount) {\n                break;\n            }\n        }\n        var tempArray = new Uint8Array(iLengthsCount);\n        tempArray.set(arrResultingCodeLengths.subarray(0, iLengthsCount), 0);\n        //sourceArray, sourceIndex, destinationArray, destinationIndex, length\n        //Array.copy( arrResultingCodeLengths, 0, tempArray, 0, iLengthsCount );\n        lengthTree = new DecompressorHuffmanTree(tempArray);\n        tempArray = arrResultingCodeLengths.slice(iLengthsCount, iLengthsCount + iDistancesCount);\n        //Array.copy( arrResultingCodeLengths, iLengthsCount, tempArray, 0, iDistancesCount );\n        distanceTree = new DecompressorHuffmanTree(tempArray);\n        return { 'lengthTree': lengthTree, 'distanceTree': distanceTree };\n    };\n    /// <summary>\n    /// Decodes huffman codes.\n    /// </summary>\n    /// <returns>True if some data was read.</returns>\n    CompressedStreamReader.prototype.readHuffman = function () {\n        var free = this.DEF_MAX_WINDOW_SIZE - (this.mDataLength - this.mCurrentPosition);\n        var dataRead = false;\n        //long maxdistance = DEF_MAX_WINDOW_SIZE >> 1;\n        var readdata = {};\n        // DEF_HUFFMAN_REPEATE_MAX - longest repeatable block, we should always reserve space for it because\n        // if we should not, we will have buffer overrun.\n        while (free >= this.DEF_HUFFMAN_REPEATE_MAX) {\n            var symbol = void 0;\n            symbol = this.mCurrentLengthTree.unpackSymbol(this);\n            // Only codes 0..255 are valid independent symbols.\n            while (((symbol) & ~0xff) === 0) {\n                readdata[(this.mDataLength + 1) % this.DEF_MAX_WINDOW_SIZE] = symbol;\n                this.mBlockBuffer[this.mDataLength++ % this.DEF_MAX_WINDOW_SIZE] = symbol;\n                dataRead = true;\n                if (--free < this.DEF_HUFFMAN_REPEATE_MAX) {\n                    return true;\n                }\n                //if( (mDataLength - mCurrentPosition ) < maxdistance ) return true;\n                symbol = this.mCurrentLengthTree.unpackSymbol(this);\n            }\n            if (symbol < this.DEF_HUFFMAN_LENGTH_MINIMUMCODE) {\n                if (symbol < this.DEF_HUFFMAN_END_BLOCK) {\n                    throw new DOMException('Illegal code.');\n                }\n                var numDataRead = dataRead ? 1 : 0;\n                this.mbCanReadMoreData = this.decodeBlockHeader();\n                var numReadMore = (this.mbCanReadMoreData) ? 1 : 0;\n                return (numDataRead | numReadMore) ? true : false;\n            }\n            if (symbol > this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE) {\n                throw new DOMException('Illegal repeat code length.');\n            }\n            var iRepeatLength = CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_BASE[symbol -\n                this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];\n            var iRepeatExtraBits = CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION[symbol -\n                this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];\n            if (iRepeatExtraBits > 0) {\n                var extra = this.readBits(iRepeatExtraBits);\n                if (extra < 0) {\n                    throw new DOMException('Wrong data.');\n                }\n                iRepeatLength += extra;\n            }\n            // Unpack repeat distance.\n            symbol = this.mCurrentDistanceTree.unpackSymbol(this);\n            if (symbol < 0 || symbol > CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE.length) {\n                throw new DOMException('Wrong distance code.');\n            }\n            var iRepeatDistance = CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE[symbol];\n            iRepeatExtraBits = CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION[symbol];\n            if (iRepeatExtraBits > 0) {\n                var extra = this.readBits(iRepeatExtraBits);\n                if (extra < 0) {\n                    throw new DOMException('Wrong data.');\n                }\n                iRepeatDistance += extra;\n            }\n            // Copy data in slow repeat mode\n            for (var i = 0; i < iRepeatLength; i++) {\n                this.mBlockBuffer[this.mDataLength % this.DEF_MAX_WINDOW_SIZE] =\n                    this.mBlockBuffer[(this.mDataLength - iRepeatDistance) % this.DEF_MAX_WINDOW_SIZE];\n                this.mDataLength++;\n                free--;\n            }\n            dataRead = true;\n        }\n        return dataRead;\n    };\n    /// <summary>\n    /// Reads data to buffer.\n    /// </summary>\n    /// <param name=\"buffer\">Output buffer for data.</param>\n    /// <param name=\"offset\">Offset in output data.</param>\n    /// <param name=\"length\">Length of the data to be read.</param>\n    /// <returns>Count of bytes actually read.</returns>\n    CompressedStreamReader.prototype.read = function (buffer, offset, length) {\n        if (buffer == null) {\n            throw new DOMException('buffer');\n        }\n        if (offset < 0 || offset > buffer.length - 1) {\n            throw new DOMException('offset', 'Offset does not belong to specified buffer.');\n        }\n        if (length < 0 || length > buffer.length - offset) {\n            throw new DOMException('length', 'Length is illegal.');\n        }\n        var initialLength = length;\n        while (length > 0) {\n            // Read from internal buffer.\n            if (this.mCurrentPosition < this.mDataLength) {\n                // Position in buffer array.\n                var inBlockPosition = (this.mCurrentPosition % this.DEF_MAX_WINDOW_SIZE);\n                // We can not read more than we have in buffer at once,\n                // and we not read more than till the array end.\n                var dataToCopy = Math.min(this.DEF_MAX_WINDOW_SIZE - inBlockPosition, (this.mDataLength - this.mCurrentPosition));\n                // Reading not more, than the rest of the buffer.\n                dataToCopy = Math.min(dataToCopy, length);\n                //sourceArray, sourceIndex, destinationArray, destinationIndex, length\n                // Copy data.\n                //Array.Copy( mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy );\n                //buffer.set(this.mBlockBuffer.slice(inBlockPosition, dataToCopy), offset);\n                Utils.arrayCopy(this.mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy);\n                // Correct position, length,\n                this.mCurrentPosition += dataToCopy;\n                offset += dataToCopy;\n                length -= dataToCopy;\n            }\n            else {\n                if (!this.mbCanReadMoreData) {\n                    break;\n                }\n                var oldDataLength = this.mDataLength;\n                if (!this.mbReadingUncompressed) {\n                    if (!this.readHuffman()) {\n                        break;\n                    }\n                }\n                else {\n                    if (this.mUncompressedDataLength === 0) {\n                        // If there is no more data in stream, just exit.\n                        this.mbCanReadMoreData = this.decodeBlockHeader();\n                        if (!(this.mbCanReadMoreData)) {\n                            break;\n                        }\n                    }\n                    else {\n                        // Position of the data end in block buffer.\n                        var inBlockPosition = (this.mDataLength % this.DEF_MAX_WINDOW_SIZE);\n                        var dataToRead = Math.min(this.mUncompressedDataLength, this.DEF_MAX_WINDOW_SIZE - inBlockPosition);\n                        var dataRead = this.readPackedBytes(this.mBlockBuffer, inBlockPosition, dataToRead);\n                        if (dataToRead !== dataRead) {\n                            throw new DOMException('Not enough data in stream.');\n                        }\n                        this.mUncompressedDataLength -= dataRead;\n                        this.mDataLength += dataRead;\n                    }\n                }\n                if (oldDataLength < this.mDataLength) {\n                    var start = (oldDataLength % this.DEF_MAX_WINDOW_SIZE);\n                    var end = (this.mDataLength % this.DEF_MAX_WINDOW_SIZE);\n                    if (start < end) {\n                        this.checksumUpdate(this.mBlockBuffer, start, end - start);\n                    }\n                    else {\n                        this.checksumUpdate(this.mBlockBuffer, start, this.DEF_MAX_WINDOW_SIZE - start);\n                        if (end > 0) {\n                            this.checksumUpdate(this.mBlockBuffer, 0, end);\n                        }\n                    }\n                }\n            }\n        }\n        if (!this.mbCanReadMoreData && !this.mbCheckSumRead && !this.mbNoWrap) {\n            this.skipToBoundary();\n            var checkSum = this.readInt32();\n            //Debug.Assert( checkSum == mCheckSum, \"\" );\n            if (checkSum !== this.mCheckSum) {\n                throw new DOMException('Checksum check failed.');\n            }\n            this.mbCheckSumRead = true;\n        }\n        return initialLength - length;\n    };\n    /// <summary>\n    /// Reads array of bytes.\n    /// </summary>\n    /// <param name=\"buffer\">Output buffer.</param>\n    /// <param name=\"offset\">Offset in output buffer.</param>\n    /// <param name=\"length\">Length of the data to be read.</param>\n    /// <returns>Count of bytes actually read to the buffer.</returns>\n    CompressedStreamReader.prototype.readPackedBytes = function (buffer, offset, length) {\n        if (buffer == null) {\n            throw new DOMException('buffer');\n        }\n        if (offset < 0 || offset > buffer.length - 1) {\n            throw new DOMException('offset\", \"Offset can not be less than zero or greater than buffer length - 1.');\n        }\n        if (length < 0) {\n            throw new DOMException('length\", \"Length can not be less than zero.');\n        }\n        if (length > buffer.length - offset) {\n            throw new DOMException('length\", \"Length is too large.');\n        }\n        if ((this.mBufferedBits & 7) !== 0) {\n            throw new DOMException('Reading of unalligned data is not supported.');\n        }\n        if (length === 0) {\n            return 0;\n        }\n        var result = 0;\n        while (this.mBufferedBits > 0 && length > 0) {\n            buffer[offset++] = (this.mBuffer);\n            this.mBufferedBits -= 8;\n            this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> 8);\n            length--;\n            result++;\n        }\n        if (length > 0) {\n            //TODO: Fix this.\n            result += this.mInputStream.read(buffer, offset, length);\n        }\n        return result;\n    };\n    /// <summary>\n    /// TODO: place correct comment here\n    /// </summary>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readInt32 = function () {\n        var result = this.readBits(8) << 24;\n        result |= this.readBits(8) << 16;\n        result |= this.readBits(8) << 8;\n        result |= this.readBits(8);\n        return result;\n    };\n    /// <summary>\n    /// Updates checksum by calculating checksum of the\n    /// given buffer and adding it to current value.\n    /// </summary>\n    /// <param name=\"buffer\">Data byte array.</param>\n    /// <param name=\"offset\">Offset in the buffer.</param>\n    /// <param name=\"length\">Length of data to be used from the stream.</param>\n    CompressedStreamReader.prototype.checksumUpdate = function (buffer, offset, length) {\n        ChecksumCalculator.ChecksumUpdate(this.mCheckSum, buffer, offset, length);\n    };\n    CompressedStreamReader.DEF_REVERSE_BITS = new Uint8Array([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]);\n    /// <summary>\n    /// Minimum count of repetions.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS = [3, 3, 11];\n    /// <summary>\n    /// Bits, that responds for different repetion modes.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_BITS = [2, 3, 7];\n    /// <summary>\n    /// Length bases.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_BASE = [\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258\n    ];\n    /// <summary>\n    /// Length extended bits count.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION = [\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0\n    ];\n    /// <summary>\n    /// Distance bases.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE = [\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577\n    ];\n    /// <summary>\n    /// Distance extanded bits count.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION = [\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13\n    ];\n    return CompressedStreamReader;\n}());\nexport { CompressedStreamReader };\nvar Stream = /** @class */ (function () {\n    function Stream(input) {\n        this.position = 0;\n        this.inputStream = new Uint8Array(input.buffer);\n    }\n    Object.defineProperty(Stream.prototype, \"length\", {\n        get: function () {\n            return this.inputStream.buffer.byteLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Stream.prototype.read = function (buffer, start, length) {\n        var temp = new Uint8Array(this.inputStream.buffer, this.position + start);\n        var data = temp.subarray(0, length);\n        buffer.set(data, 0);\n        this.position += data.byteLength;\n        return data.byteLength;\n    };\n    Stream.prototype.readByte = function () {\n        return this.inputStream[this.position++];\n    };\n    Stream.prototype.write = function (inputBuffer, offset, count) {\n        Utils.arrayCopy(inputBuffer, 0, this.inputStream, this.position + offset, count);\n        // this.inputStream = new Uint8Array(this.inputStream.buffer, this.position + offset);\n        // this.inputStream.set(inputBuffer, offset);\n        this.position += count;\n    };\n    Stream.prototype.toByteArray = function () {\n        return new Uint8Array(this.inputStream.buffer);\n    };\n    return Stream;\n}());\nexport { Stream };\n/* eslint-enable */ \n", "/* eslint-disable */\nimport { CompressedStreamWriter, Stream, CompressedStreamReader } from './index';\nimport { Save } from '@syncfusion/ej2-file-utils';\nimport { Utils } from './utils';\nvar CRC32TABLE = [];\n/// <summary>\n/// Size of the int value in bytes.\n/// </summary>\nvar INT_SIZE = 4;\n/// <summary>\n/// Size of the short value in bytes.\n/// </summary>\nvar SHORT_SIZE = 2;\n/// <summary>\n/// End of central directory signature.\n/// </summary>\nvar CentralDirectoryEndSignature = 0x06054b50;\n/// <summary>\n/// Offset to the size field in the End of central directory record.\n/// </summary>\nvar CentralDirSizeOffset = 12;\n/// <summary>\n/// Central header signature.\n/// </summary>\nvar CentralHeaderSignature = 0x02014b50;\n/// <summary>\n/// Buffer size.\n/// </summary>\nvar BufferSize = 4096;\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\nvar ZipArchive = /** @class */ (function () {\n    /**\n     * constructor for creating ZipArchive instance\n     */\n    function ZipArchive() {\n        if (CRC32TABLE.length === 0) {\n            ZipArchive.initCrc32Table();\n        }\n        this.files = [];\n        this.level = 'Normal';\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    Object.defineProperty(ZipArchive.prototype, \"items\", {\n        get: function () {\n            return this.files;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchive.prototype, \"compressionLevel\", {\n        /**\n         * gets compression level\n         */\n        get: function () {\n            return this.level;\n        },\n        /**\n         * sets compression level\n         */\n        set: function (level) {\n            this.level = level;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchive.prototype, \"length\", {\n        /**\n         * gets items count\n         */\n        get: function () {\n            if (this.files === undefined) {\n                return 0;\n            }\n            return this.files.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * add new item to archive\n     * @param {ZipArchiveItem} item - item to be added\n     * @returns {void}\n     */\n    ZipArchive.prototype.addItem = function (item) {\n        if (item === null || item === undefined) {\n            throw new Error('ArgumentException: item cannot be null or undefined');\n        }\n        for (var i = 0; i < this.files.length; i++) {\n            var file = this.files[i];\n            if (file instanceof ZipArchiveItem) {\n                if (file.name === item.name) {\n                    throw new Error('item with same name already exist');\n                }\n            }\n        }\n        this.files.push(item);\n    };\n    /**\n     * add new directory to archive\n     * @param directoryName directoryName to be created\n     * @returns {void}\n     */\n    ZipArchive.prototype.addDirectory = function (directoryName) {\n        if (directoryName === null || directoryName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (directoryName.length === 0) {\n            throw new Error('ArgumentException: string cannot be empty');\n        }\n        if (directoryName.slice(-1) !== '/') {\n            directoryName += '/';\n        }\n        if (this.files.indexOf(directoryName) !== -1) {\n            throw new Error('item with same name already exist');\n        }\n        this.files.push(directoryName);\n    };\n    /**\n     * gets item at specified index\n     * @param {number} index - item index\n     * @returns {ZipArchiveItem}\n     */\n    ZipArchive.prototype.getItem = function (index) {\n        if (index >= 0 && index < this.files.length) {\n            return this.files[index];\n        }\n        return undefined;\n    };\n    /**\n     * determines whether an element is in the collection\n     * @param {string | ZipArchiveItem} item - item to search\n     * @returns {boolean}\n     */\n    ZipArchive.prototype.contains = function (item) {\n        return this.files.indexOf(item) !== -1 ? true : false;\n    };\n    ZipArchive.prototype.open = function (base64String) {\n        //return promise = new Promise((resolve: Function, reject: Function) => {\n        var zipArchive = this;\n        var zipByteArray = Utils.encodedString(base64String);\n        if (zipByteArray.length == 0)\n            throw new DOMException(\"stream\");\n        var stream = new Stream(zipByteArray);\n        //let lCentralDirEndPosition = this.findValueFromEnd( arrBuffer, Constants.CentralDirectoryEndSignature, 65557 );\n        var lCentralDirEndPosition = ZipArchive.findValueFromEnd(stream, CentralDirectoryEndSignature, 65557);\n        if (lCentralDirEndPosition < 0)\n            throw new DOMException(\"Can't locate end of central directory record. Possible wrong file format or archive is corrupt.\");\n        // Step2. Locate central directory and iterate through all items\n        stream.position = lCentralDirEndPosition + CentralDirSizeOffset;\n        var iCentralDirSize = ZipArchive.ReadInt32(stream);\n        var lCentralDirPosition = lCentralDirEndPosition - iCentralDirSize;\n        // verify that this is really central directory\n        stream.position = lCentralDirPosition;\n        this.readCentralDirectoryDataAndExtractItems(stream);\n        //});\n        // let zipArchive: ZipArchive = this;\n        //let promise: Promise<ZipArchive>;\n        // return promise = new Promise((resolve: Function, reject: Function) => {\n        //     let reader: FileReader = new FileReader();\n        //     reader.onload = (e: Event) => {\n        //         let data: Uint8Array = new Uint8Array((e.target as any).result);\n        //         let zipReader: ZipReader = new ZipReader(data);\n        //         zipReader.readEntries().then((entries: ZipEntry[]) => {\n        //             for (let i: number = 0; i < entries.length; i++) {\n        //                 let entry: ZipEntry = entries[i];\n        //                 let item: ZipArchiveItem = new ZipArchiveItem(zipArchive, entry.fileName);\n        //                 item.data = entry.data;\n        //                 item.compressionMethod = entry.compressionMethod;\n        //                 item.crc = entry.crc;\n        //                 item.lastModified = entry.lastModified;\n        //                 item.lastModifiedDate = entry.lastModifiedDate;\n        //                 item.size = entry.size;\n        //                 item.uncompressedSize = entry.uncompressedSize;\n        //                 zipArchive.addItem(item);\n        //             }\n        //             resolve(zipArchive);\n        //         });\n        //     };\n        //     reader.readAsArrayBuffer(fileName);\n        // });\n    };\n    /// <summary>\n    /// Read central directory record from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read from.</param>\n    ZipArchive.prototype.readCentralDirectoryDataAndExtractItems = function (stream) {\n        if (stream == null)\n            throw new DOMException(\"stream\");\n        var itemHelper;\n        while (ZipArchive.ReadInt32(stream) == CentralHeaderSignature) {\n            itemHelper = new ZipArchiveItemHelper();\n            itemHelper.readCentralDirectoryData(stream);\n            itemHelper;\n            // let item: ZipArchiveItem = new ZipArchiveItem(this);\n            // item.ReadCentralDirectoryData(stream);\n            // m_arrItems.Add(item);\n        }\n        itemHelper.readData(stream, itemHelper.checkCrc);\n        itemHelper.decompressData();\n        this.files.push(new ZipArchiveItem(itemHelper.unCompressedStream.buffer, itemHelper.name));\n    };\n    /**\n     * save archive with specified file name\n     * @param {string} fileName save archive with specified file name\n     * @returns {Promise<ZipArchive>}\n     */\n    ZipArchive.prototype.save = function (fileName) {\n        if (fileName === null || fileName === undefined || fileName.length === 0) {\n            throw new Error('ArgumentException: fileName cannot be null or undefined');\n        }\n        if (this.files.length === 0) {\n            throw new Error('InvalidOperation');\n        }\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal(fileName, false).then(function () {\n                resolve(zipArchive);\n            });\n        });\n    };\n    /**\n     * Save archive as blob\n     * @return {Promise<Blob>}\n     */\n    ZipArchive.prototype.saveAsBlob = function () {\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal('', true).then(function (blob) {\n                resolve(blob);\n            });\n        });\n    };\n    ZipArchive.prototype.saveInternal = function (fileName, skipFileSave) {\n        var _this = this;\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            var zipData = [];\n            var dirLength = 0;\n            for (var i = 0; i < zipArchive.files.length; i++) {\n                var compressedObject = _this.getCompressedData(_this.files[i]);\n                compressedObject.then(function (data) {\n                    dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n                    if (zipData.length === zipArchive.files.length) {\n                        var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n                        resolve(blob);\n                    }\n                });\n            }\n        });\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchive.prototype.destroy = function () {\n        if (this.files !== undefined && this.files.length > 0) {\n            for (var i = 0; i < this.files.length; i++) {\n                var file = this.files[i];\n                if (file instanceof ZipArchiveItem) {\n                    file.destroy();\n                }\n                file = undefined;\n            }\n            this.files = [];\n        }\n        this.files = undefined;\n        this.level = undefined;\n    };\n    ZipArchive.prototype.getCompressedData = function (item) {\n        var zipArchive = this;\n        var promise = new Promise(function (resolve, reject) {\n            if (item instanceof ZipArchiveItem) {\n                var reader_1 = new FileReader();\n                reader_1.onload = function () {\n                    var input = new Uint8Array(reader_1.result);\n                    var data = {\n                        fileName: item.name, crc32Value: 0, compressedData: [],\n                        compressedSize: undefined, uncompressedDataSize: input.length, compressionType: undefined,\n                        isDirectory: false\n                    };\n                    if (zipArchive.level === 'Normal') {\n                        zipArchive.compressData(input, data, CRC32TABLE);\n                        var length_1 = 0;\n                        for (var i = 0; i < data.compressedData.length; i++) {\n                            length_1 += data.compressedData[i].length;\n                        }\n                        data.compressedSize = length_1;\n                        data.compressionType = '\\x08\\x00'; //Deflated = 8\n                    }\n                    else {\n                        data.compressedSize = input.length;\n                        data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n                        data.compressionType = '\\x00\\x00'; // Stored = 0\n                        data.compressedData.push(input);\n                    }\n                    resolve(data);\n                };\n                reader_1.readAsArrayBuffer(item.data);\n            }\n            else {\n                var data = {\n                    fileName: item, crc32Value: 0, compressedData: '', compressedSize: 0, uncompressedDataSize: 0,\n                    compressionType: '\\x00\\x00', isDirectory: true\n                };\n                resolve(data);\n            }\n        });\n        return promise;\n    };\n    ZipArchive.prototype.compressData = function (input, data, crc32Table) {\n        var compressor = new CompressedStreamWriter(true);\n        var currentIndex = 0;\n        var nextIndex = 0;\n        do {\n            if (currentIndex >= input.length) {\n                compressor.close();\n                break;\n            }\n            nextIndex = Math.min(input.length, currentIndex + 16384);\n            var subArray = input.subarray(currentIndex, nextIndex);\n            data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n            compressor.write(subArray, 0, nextIndex - currentIndex);\n            currentIndex = nextIndex;\n        } while (currentIndex <= input.length);\n        data.compressedData = compressor.compressedData;\n        compressor.destroy();\n    };\n    ZipArchive.prototype.constructZippedObject = function (zipParts, data, dirLength, isDirectory) {\n        var extFileAttr = 0;\n        var date = new Date();\n        if (isDirectory) {\n            extFileAttr = extFileAttr | 0x00010; // directory flag\n        }\n        extFileAttr = extFileAttr | (0 & 0x3F);\n        var header = this.writeHeader(data, date);\n        var localHeader = 'PK\\x03\\x04' + header + data.fileName;\n        var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n        zipParts.push({ localHeader: localHeader, centralDir: centralDir, compressedData: data });\n        return dirLength + localHeader.length + data.compressedSize;\n    };\n    ZipArchive.prototype.writeHeader = function (data, date) {\n        var zipHeader = '';\n        zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n        zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n        zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n        zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n        zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n        zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n        zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n        zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n        zipHeader += this.getBytes(0, 2); // extra field length\n        return zipHeader;\n    };\n    ZipArchive.prototype.writeZippedContent = function (fileName, zipData, localDirLen, skipFileSave) {\n        var cenDirLen = 0;\n        var buffer = [];\n        for (var i = 0; i < zipData.length; i++) {\n            var item = zipData[i];\n            cenDirLen += item.centralDir.length;\n            buffer.push(this.getArrayBuffer(item.localHeader));\n            while (item.compressedData.compressedData.length) {\n                buffer.push(item.compressedData.compressedData.shift().buffer);\n            }\n        }\n        for (var i = 0; i < zipData.length; i++) {\n            buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n        }\n        buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n        var blob = new Blob(buffer, { type: 'application/zip' });\n        if (!skipFileSave) {\n            Save.save(fileName, blob);\n        }\n        return blob;\n    };\n    ZipArchive.prototype.writeCentralDirectory = function (data, localHeader, offset, externalFileAttribute) {\n        var directoryHeader = 'PK\\x01\\x02' +\n            this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n            this.getBytes(0, 2) + // comment length\n            '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n            this.getBytes(externalFileAttribute, 4) + // external file attributes\n            this.getBytes(offset, 4) + // local fileHeader relative offset\n            data.fileName;\n        return directoryHeader;\n    };\n    ZipArchive.prototype.writeFooter = function (zipData, centralLength, localLength) {\n        var dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' +\n            this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) +\n            this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) +\n            this.getBytes(0, 2);\n        return dirEnd;\n    };\n    ZipArchive.prototype.getArrayBuffer = function (input) {\n        var a = new Uint8Array(input.length);\n        for (var j = 0; j < input.length; ++j) {\n            a[j] = input.charCodeAt(j) & 0xFF;\n        }\n        return a.buffer;\n    };\n    ZipArchive.prototype.getBytes = function (value, offset) {\n        var bytes = '';\n        for (var i = 0; i < offset; i++) {\n            bytes += String.fromCharCode(value & 0xff);\n            value = value >>> 8;\n        }\n        return bytes;\n    };\n    ZipArchive.prototype.getModifiedTime = function (date) {\n        var modTime = date.getHours();\n        modTime = modTime << 6;\n        modTime = modTime | date.getMinutes();\n        modTime = modTime << 5;\n        return modTime = modTime | date.getSeconds() / 2;\n    };\n    ZipArchive.prototype.getModifiedDate = function (date) {\n        var modiDate = date.getFullYear() - 1980;\n        modiDate = modiDate << 4;\n        modiDate = modiDate | (date.getMonth() + 1);\n        modiDate = modiDate << 5;\n        return modiDate = modiDate | date.getDate();\n    };\n    ZipArchive.prototype.calculateCrc32Value = function (crc32Value, input, crc32Table) {\n        crc32Value ^= -1;\n        for (var i = 0; i < input.length; i++) {\n            crc32Value = (crc32Value >>> 8) ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n        }\n        return (crc32Value ^ (-1));\n    };\n    /**\n     * construct cyclic redundancy code table\n     * @private\n     */\n    ZipArchive.initCrc32Table = function () {\n        var i;\n        for (var j = 0; j < 256; j++) {\n            i = j;\n            for (var k = 0; k < 8; k++) {\n                i = ((i & 1) ? (0xEDB88320 ^ (i >>> 1)) : (i >>> 1));\n            }\n            CRC32TABLE[j] = i;\n        }\n    };\n    ZipArchive.findValueFromEnd = function (stream, value, maxCount) {\n        if (stream == null)\n            throw new DOMException(\"stream\");\n        //   if( !stream.CanSeek || !stream.CanRead )\n        //     throw new ArgumentOutOfRangeException( \"We need to have seekable and readable stream.\" );\n        // read last 4 bytes and compare with required value\n        var lStreamSize = stream.inputStream.buffer.byteLength;\n        if (lStreamSize < 4)\n            return -1;\n        var arrBuffer = new Uint8Array(4);\n        var lLastPos = Math.max(0, lStreamSize - maxCount);\n        var lCurrentPosition = lStreamSize - 1 - INT_SIZE;\n        stream.position = lCurrentPosition;\n        stream.read(arrBuffer, 0, INT_SIZE);\n        var uiCurValue = arrBuffer[0];\n        var bFound = (uiCurValue == value);\n        if (!bFound) {\n            while (lCurrentPosition > lLastPos) {\n                // remove unnecessary byte and replace it with new value.\n                uiCurValue <<= 8;\n                lCurrentPosition--;\n                stream.position = lCurrentPosition;\n                uiCurValue += stream.readByte();\n                if (uiCurValue == value) {\n                    bFound = true;\n                    break;\n                }\n            }\n        }\n        return bFound ? lCurrentPosition : -1;\n    };\n    /// <summary>\n    /// Extracts Int32 value from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <returns>Extracted value.</returns>\n    ZipArchive.ReadInt32 = function (stream) {\n        var buffer = new Uint8Array(INT_SIZE);\n        if (stream.read(buffer, 0, INT_SIZE) != INT_SIZE) {\n            throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n        }\n        return Utils.bitConverterToInt32(buffer, 0);\n    };\n    /// <summary>\n    /// Extracts Int16 value from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <returns>Extracted value.</returns>\n    ZipArchive.ReadInt16 = function (stream) {\n        var buffer = new Uint8Array(SHORT_SIZE);\n        if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {\n            throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n        }\n        return Utils.bitConverterToInt16(buffer, 0);\n    };\n    /// <summary>\n    /// Extracts unsigned Int16 value from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <returns>Extracted value.</returns>\n    ZipArchive.ReadUInt16 = function (stream) {\n        {\n            var buffer = new Uint8Array(SHORT_SIZE);\n            if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {\n                throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n            }\n            return Utils.bitConverterToInt16(buffer, 0);\n        }\n    };\n    return ZipArchive;\n}());\nexport { ZipArchive };\nvar ZipArchiveItemHelper = /** @class */ (function () {\n    function ZipArchiveItemHelper() {\n        /// <summary>\n        /// Zip header signature.\n        /// </summary>\n        this.headerSignature = 0x04034b50;\n        /// <summary>\n        /// Indicates whether we should check Crc value when reading item's data. Check\n        /// is performed when user gets access to decompressed data for the first time.\n        /// </summary>\n        this.checkCrc = true;\n        /// <summary>\n        /// Crc.\n        /// </summary>\n        this.crc32 = 0;\n    }\n    /// <summary>\n    /// Read data from the stream based on the central directory.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from, stream.Position must point at just after correct file header.</param>\n    ZipArchiveItemHelper.prototype.readCentralDirectoryData = function (stream) {\n        // on the current moment we ignore \"version made by\" and \"version needed to extract\" fields.\n        stream.position += 4;\n        this.options = ZipArchive.ReadInt16(stream);\n        this.compressionMethod = ZipArchive.ReadInt16(stream);\n        this.checkCrc = (this.compressionMethod != 99); //COmpression.Defalte != SecurityConstants.AES\n        //m_bCompressed = true;\n        // on the current moment we ignore \"last mod file time\" and \"last mod file date\" fields.\n        var lastModified = ZipArchive.ReadInt32(stream);\n        //LastModified = ConvertToDateTime(lastModified);\n        this.crc32 = Utils.bitConverterToUInt32(ZipArchive.ReadInt32(stream));\n        this.compressedSize = ZipArchive.ReadInt32(stream);\n        this.originalSize = ZipArchive.ReadInt32(stream);\n        var iFileNameLength = ZipArchive.ReadInt16(stream);\n        var iExtraFieldLenth = ZipArchive.ReadInt16(stream);\n        var iCommentLength = ZipArchive.ReadInt16(stream);\n        // on the current moment we ignore and \"disk number start\" (2 bytes),\n        // \"internal file attributes\" (2 bytes).\n        stream.position += 4;\n        this.externalAttributes = ZipArchive.ReadInt32(stream);\n        this.localHeaderOffset = ZipArchive.ReadInt32(stream);\n        var arrBuffer = new Uint8Array(iFileNameLength);\n        stream.read(arrBuffer, 0, iFileNameLength);\n        var m_strItemName = Utils.byteToString(arrBuffer);\n        m_strItemName = m_strItemName.replace(\"\\\\\", \"/\");\n        this.name = m_strItemName;\n        stream.position += iExtraFieldLenth + iCommentLength;\n        if (this.options != 0)\n            this.options = 0;\n    };\n    /// <summary>\n    /// Reads zipped data from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <param name=\"checkCrc\">Indicates whether we should check crc value after data decompression.</param>\n    ZipArchiveItemHelper.prototype.readData = function (stream, checkCrc) {\n        if (stream.length == 0)\n            throw new DOMException(\"stream\");\n        stream.position = this.localHeaderOffset;\n        this.checkCrc = checkCrc;\n        this.readLocalHeader(stream);\n        this.readCompressedData(stream);\n    };\n    ZipArchiveItemHelper.prototype.decompressData = function () {\n        if (this.compressionMethod == 8) {\n            if (this.originalSize > 0) {\n                this.decompressDataOld();\n            }\n        }\n    };\n    ZipArchiveItemHelper.prototype.decompressDataOld = function () {\n        var reader = new CompressedStreamReader(this.compressedStream, true);\n        var decompressedData;\n        if (this.originalSize > 0)\n            decompressedData = new Stream(new Uint8Array(this.originalSize));\n        var arrBuffer = new Uint8Array(BufferSize);\n        var iReadBytes;\n        var past = new Uint8Array(0);\n        while ((iReadBytes = reader.read(arrBuffer, 0, BufferSize)) > 0) {\n            //             past = new Uint8Array(decompressedData.length);\n            // let currentBlock: Uint8Array = arrBuffer.subarray(0, iReadBytes);\n            decompressedData.write(arrBuffer.subarray(0, iReadBytes), 0, iReadBytes);\n        }\n        this.unCompressedStream = decompressedData.toByteArray();\n        //   this.originalSize = decompressedData.Length;\n        //   m_bControlStream = true;\n        //   m_streamData = decompressedData;\n        //   decompressedData.SetLength( m_lOriginalSize );\n        //   decompressedData.Capacity = ( int )m_lOriginalSize;\n        if (this.checkCrc) {\n            //TODO: fix this\n            //CheckCrc(decompressedData.ToArray());\n        }\n        //m_streamData.Position = 0;\n    };\n    /// <summary>\n    /// Extracts local header from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    ZipArchiveItemHelper.prototype.readLocalHeader = function (stream) {\n        if (stream.length == 0)\n            throw new DOMException(\"stream\");\n        if (ZipArchive.ReadInt32(stream) != this.headerSignature)\n            throw new DOMException(\"Can't find local header signature - wrong file format or file is corrupt.\");\n        // TODO: it is good to verify data read from the central directory record,\n        // but on the current moment we simply skip it.\n        stream.position += 22;\n        var iNameLength = ZipArchive.ReadInt16(stream);\n        var iExtraLength = ZipArchive.ReadUInt16(stream);\n        if (this.compressionMethod == 99) //SecurityConstants.AES\n         {\n            // stream.Position += iNameLength + 8;\n            // m_archive.EncryptionAlgorithm = (EncryptionAlgorithm)stream.ReadByte();\n            // m_actualCompression = new byte[2];\n            // stream.Read(m_actualCompression, 0, 2);\n        }\n        else if (iExtraLength > 2) {\n            stream.position += iNameLength;\n            var headerVal = ZipArchive.ReadInt16(stream);\n            if (headerVal == 0x0017) //PKZipEncryptionHeader\n                throw new DOMException(\"UnSupported\");\n            else\n                stream.position += iExtraLength - 2;\n        }\n        else\n            stream.position += iNameLength + iExtraLength;\n    };\n    /// <summary>\n    /// Extracts compressed data from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    ZipArchiveItemHelper.prototype.readCompressedData = function (stream) {\n        var dataStream;\n        if (this.compressedSize > 0) {\n            var iBytesLeft = this.compressedSize;\n            dataStream = new Stream(new Uint8Array(iBytesLeft));\n            var arrBuffer = new Uint8Array(BufferSize);\n            while (iBytesLeft > 0) {\n                var iBytesToRead = Math.min(iBytesLeft, BufferSize);\n                if (stream.read(arrBuffer, 0, iBytesToRead) != iBytesToRead)\n                    throw new DOMException(\"End of file reached - wrong file format or file is corrupt.\");\n                dataStream.write(arrBuffer.subarray(0, iBytesToRead), 0, iBytesToRead);\n                iBytesLeft -= iBytesToRead;\n            }\n            // if(m_archive.Password != null)\n            // {\n            //     byte[] dataBuffer = new byte[dataStream.Length];\n            //     dataBuffer = dataStream.ToArray();\n            //     dataStream=new MemoryStream( Decrypt(dataBuffer));\n            // }\n            this.compressedStream = new Uint8Array(dataStream.inputStream);\n            // m_bControlStream = true;\n        }\n        else if (this.compressedSize < 0) //If compression size is negative, then read until the next header signature reached.\n         {\n            //   MemoryStream dataStream = new MemoryStream();\n            //   int bt = 0;\n            //   bool proceed=true;\n            //   while (proceed)\n            //   {\n            //       if ((bt = stream.ReadByte()) == Constants.HeaderSignatureStartByteValue)\n            //       {\n            //           stream.Position -= 1;\n            //           int headerSignature = ZipArchive.ReadInt32(stream);\n            //           if (headerSignature==Constants.CentralHeaderSignature || headerSignature==Constants.CentralHeaderSignature)\n            //           {\n            //               proceed = false;\n            //           }\n            //           stream.Position -= 3;\n            //       }\n            //       if (proceed)\n            //           dataStream.WriteByte((byte)bt);\n            //   }\n            //   m_streamData = dataStream;\n            //   m_lCompressedSize = m_streamData.Length;\n            //   m_bControlStream = true;\n        }\n        else if (this.compressedSize == 0) {\n            //  m_streamData = new MemoryStream();\n        }\n    };\n    return ZipArchiveItemHelper;\n}());\nexport { ZipArchiveItemHelper };\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\nvar ZipArchiveItem = /** @class */ (function () {\n    /**\n     * constructor for creating {ZipArchiveItem} instance\n     * @param {Blob|ArrayBuffer} data file data\n     * @param {itemName} itemName absolute file path\n     */\n    function ZipArchiveItem(data, itemName) {\n        if (data === null || data === undefined) {\n            throw new Error('ArgumentException: data cannot be null or undefined');\n        }\n        if (itemName === null || itemName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (itemName.length === 0) {\n            throw new Error('string cannot be empty');\n        }\n        this.data = data;\n        this.name = itemName;\n    }\n    Object.defineProperty(ZipArchiveItem.prototype, \"dataStream\", {\n        get: function () {\n            return this.decompressedStream;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchiveItem.prototype, \"name\", {\n        /**\n         * Get the name of archive item\n         * @returns string\n         */\n        get: function () {\n            return this.fileName;\n        },\n        /**\n         * Set the name of archive item\n         * @param  {string} value\n         */\n        set: function (value) {\n            this.fileName = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchiveItem.prototype.destroy = function () {\n        this.fileName = undefined;\n        this.data = undefined;\n    };\n    return ZipArchiveItem;\n}());\nexport { ZipArchiveItem };\n/* eslint-enable */ \n"],
  "mappings": "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",
  "names": ["Save", "isPopupBlocked", "XmlWriter", "Namespace", "XmlElement", "XmlAttribute", "Encoding", "StreamWriter", "CompressedStreamWriter", "CompressorHuffmanTree", "ChecksumCalculator", "Utils", "DecompressorHuffmanTree", "ChecksumCalculator", "CompressedStreamReader", "ChecksumCalculator", "Stream", "ZipArchive", "data", "ZipArchiveItemHelper", "ZipArchiveItem"]
}
